# A0139942W
###### \java\seedu\address\logic\commands\FindCommand.java
``` java
/** 
 *          Finds and lists all tasks in taskForce whose name contains any of
 *          the argument keywords. Keyword matching is case sensitive.
 */

public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: " + COMMAND_WORD + " OPTION/KEYWORDS [mark/true]\n" + "Parameters: " + COMMAND_WORD
            + " TYPE/SEARCHTYPE\n" + "Example: " + COMMAND_WORD + " name/meeting\n" + COMMAND_WORD + " day/3\n"
            + COMMAND_WORD + " week/-4\n" + COMMAND_WORD + " tag/Done mark/true\n" + COMMAND_WORD
            + " desc/Done mark/true\n" + COMMAND_WORD + " type/all\n" + COMMAND_WORD + " type/mark\n" + COMMAND_WORD
            + " type/overdue";

    public final static String INVALID_FIND_DATE_MESSAGE = "Please enter valid number when search by day/week";
    public final static String INVALID_FIND_TYPE_MESSAGE = "Find type only support overdue / all / task . ";
    
    private final String FIND_TYPE_NAME = "NAME";
    private final String FIND_TYPE_TAG = "TAG";
    private final String FIND_TYPE_DESC = "DESC";
    private final String FIND_TYPE_TYPE = "TYPE";
    private final String FIND_TYPE_ALL = "all";
    private final String FIND_TYPE_OVERDUE = "overdue";
    private final String FIND_TYPE_MARK = "mark";

    private final int VALID_NO_OF_ARG = 1;
    private final int FIND_ARGS_INDEX = 0;

    private final boolean VALID_ARG = true;
    private final boolean INVALID_ARG = false;

    private final Set<String> keywords;
    private final String typeOfFind;
    private final boolean isMarkCheck;

    public FindCommand(Set<String> keywords, String typeOfFind, boolean isMarkCheck) throws IllegalValueException {
        if (!checkKeyWord(keywords, typeOfFind)) {
            throw new IllegalValueException(INVALID_FIND_DATE_MESSAGE);
        }
        this.keywords = keywords;
        this.typeOfFind = typeOfFind;
        this.isMarkCheck = isMarkCheck;
    }

    // This method ensure that keyword for type 'day' and 'week' contain only a
    // integer number
    public boolean checkKeyWord(Set<String> keywords, String typeOfFind) throws IllegalValueException {
        if (isSearchByKeywords(typeOfFind)) {
            return VALID_ARG;
        }
        if (isSearchByType(typeOfFind, keywords)) {
            return VALID_ARG;
        }
        if (keywords.size() != VALID_NO_OF_ARG) {
            return INVALID_ARG;
        }
        List<String> getNumList = new ArrayList<String>(keywords);
        try {
            Integer.parseInt(getNumList.get(FIND_ARGS_INDEX));
        } catch (NumberFormatException e) {
            return INVALID_ARG;
        }
        return VALID_ARG;

    }

    private boolean isSearchByType(String typeOfFind, Set<String> keywords) throws IllegalValueException {
        // TODO Auto-generated method stub
        if (!typeOfFind.equals(FIND_TYPE_TYPE)) {
            return false;
        }
        if (keywords.size() != VALID_NO_OF_ARG) {
            throw new IllegalValueException(INVALID_FIND_TYPE_MESSAGE);
        }
        List<String> findTypeList = new ArrayList<String>(keywords);
        String findType = findTypeList.get(FIND_ARGS_INDEX).trim();
        if (FIND_TYPE_ALL.equalsIgnoreCase(findType) || FIND_TYPE_OVERDUE.equalsIgnoreCase(findType)
                || FIND_TYPE_MARK.equalsIgnoreCase(findType)) {
            return VALID_ARG;
        }
        throw new IllegalValueException(INVALID_FIND_TYPE_MESSAGE);
    }

    public boolean isSearchByKeywords(String typeOfFind) {
        return typeOfFind.equals(FIND_TYPE_NAME) || typeOfFind.equals(FIND_TYPE_DESC)
                || typeOfFind.equals(FIND_TYPE_TAG);
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords, typeOfFind, isMarkCheck);
        return new CommandResult(getMessageForTaskListShownSummary(model.getSortedFilteredTask().size()), true);
    }
}
```
###### \java\seedu\address\logic\commands\FreetimeCommand.java
``` java
/*
 * Finds and list out all the time slot that the user are free on that particular day 
 * All time slot are rounded up to block of 30min interval
 * It take into consideration user activeHour that are stored in config file. 
 */
public class FreetimeCommand extends Command {
    public static final String COMMAND_WORD = "freetime";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + " : Find all timeslot that user are free on that particular day \n"
            + "freetime day/1 will give u all the free time you have tomorrow\n" + "Parameters: DAY/INTEGER \n"
            + "Example: " + COMMAND_WORD + " day/1\n" + COMMAND_WORD + " day/-2";

    public static final String INVALID_FREETIME_ARGS = "Please enter a valid number eg. freetime day/5";
    public static final String ZERO_EVENT_MESSAGE = "You are free for the day, trying clearing some reminders.";
    public static final String DEFAULT_STARTING_MESSAGE = "on %1$s: ";
    public static final String NUM_OF_FREESLOT_MESSAGE = "you have %1$s freeslots";
    public static final String ONGOING_EVENT_MESSAGE = "There is a ongoing event from %1$s to %2$s \n";
    public static final String NO_FREE_TIME_MESSAGE = "There no freetime within the freetime period";

    private static final String SEARCH_TYPE = "DAY";
    private static final boolean HAS_FREE_TIME = true;
    private static final boolean DONE = true;
    private static final int ZERO_EVENT_ON_THAT_DAY = 0;
    private static final int ONE_EVENT_ON_THAT_DAY = 1;
    private static final int SEARCHED_DAY_INDEX = 0;
    private static final int FIRST_EVENT_INDEX = 0;
    private static final int HALF_AN_HOUR = 30;
    private static final int AN_HOUR = 60;
    private static final int EXACT_AN_HOUR = 00;
    private static final int LAST_TIME_BLOCK = 48;

    private ArrayList<Pair<LocalDateTime, LocalDateTime>> timeLists;
    private Map<Pair<Integer, Integer>, TimeStatus> freeTimes;
    private final Set<String> searchSets;

    private DateTimeFormatter dateFormat;
    private DateTimeFormatter datetimeFormat;
    private LocalDateTime activeHourStart;
    private LocalDateTime activeHourEnd;
    private StringBuilder freetimeMsgBuilder;
    private int noOfFreeSlot;
    
    public FreetimeCommand(String searchedDay) {
        this.searchSets = new HashSet<String>();
        this.searchSets.add(searchedDay);
        this.timeLists = new ArrayList<Pair<LocalDateTime, LocalDateTime>>();
        this.freeTimes = Maps.newHashMap();
        this.dateFormat = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        this.datetimeFormat = DateTimeFormatter.ofPattern("dd/MM/yyyy HHmm");
        this.noOfFreeSlot = 0;
        this.freetimeMsgBuilder = new StringBuilder();
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(searchSets, SEARCH_TYPE, false);
        List<ReadOnlyTask> filteredList = model.getFilteredTaskList();

        LocalDateTime searchedDay = getSearchedDay();
        setActiveHours();
        getAllEvent(filteredList);
        sortEventList();

        String freeTime = getFreeTime(searchedDay);
        return new CommandResult(freeTime, true);
    }
    
    private void setActiveHours() {
        this.activeHourStart = roundUpTime(readActiveHours("activeHoursFrom"));
        this.activeHourEnd = roundUpTime(readActiveHours("activeHoursTo"));
    }


    private LocalDateTime readActiveHours(String key) {
        Config config = model.getConfigs();
        String activeTime = config.getConfigurationOption(key);
        return formatActiveHours(activeTime);
    }
    
    private LocalDateTime formatActiveHours(String activeHours) {
        LocalDateTime searchedDay = getSearchedDay();
        DateTimeFormatter withoutTime = DateTimeFormatter.ofPattern("dd/MM/yyyy ");
        DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern("dd/MM/yyyy HHmm");
        String activeTimeDate = searchedDay.format(withoutTime) + activeHours;
        return LocalDateTime.parse(activeTimeDate, dateFormat);
    }

    private LocalDateTime getSearchedDay() {
        List<String> getTimeArg = new ArrayList<String>(searchSets);
        Long timeToAdd = Long.parseLong(getTimeArg.get(SEARCHED_DAY_INDEX));
        LocalDateTime dateToday = LocalDateTime.now();
        return dateToday.plusDays(timeToAdd);
    }

    private String getFreeTime(LocalDateTime onThatDay) {
        if (timeLists.size() == ZERO_EVENT_ON_THAT_DAY) {
            createNewFreeTimeEntry(activeHourStart, activeHourEnd, TimeStatus.FREE);
            return ZERO_EVENT_MESSAGE;
        }
        LocalDateTime currStartTime = timeLists.get(FIRST_EVENT_INDEX).getKey();
        LocalDateTime currEndTime = timeLists.get(FIRST_EVENT_INDEX).getValue();
        if (timeLists.size() == ONE_EVENT_ON_THAT_DAY) {
            return freetimeForOneEvent(currStartTime, currEndTime, onThatDay);
        }
        return freetimeForMutipleEvents(currStartTime, currEndTime, onThatDay);
    }

    
    private String freetimeForOneEvent(LocalDateTime startTime, LocalDateTime endTime, LocalDateTime searchedDay) {
        LocalDateTime tempEndTime = endTime;
        freetimeMsgBuilder.append(String.format(DEFAULT_STARTING_MESSAGE, searchedDay.format(dateFormat)));     
        if (hasNoFreetime(startTime, endTime, searchedDay.getDayOfMonth())) {
            return freetimeMsgBuilder.toString();
        }
        if (activeHourStart.isBefore(startTime)) {
            createNewFreeTimeEntry(activeHourStart, startTime, TimeStatus.FREE);
        }
        if (activeHourStart.isAfter(endTime)) {
            tempEndTime = activeHourStart;
        }
        if (activeHourEnd.isAfter(endTime)) {
            createNewFreeTimeEntry(tempEndTime, activeHourEnd, TimeStatus.FREE);
        }
        return freetimeMsgBuilder.append(String.format(NUM_OF_FREESLOT_MESSAGE, noOfFreeSlot)).toString();
    }
    
    private boolean hasNoFreetime(LocalDateTime startTime, LocalDateTime endTime, int sameDay) {
        int startTimeDay = startTime.getDayOfMonth();
        int endTimeDay = endTime.getDayOfMonth();    
        if (checkOnGoingEvent(startTimeDay, endTimeDay, sameDay)) {
            freetimeMsgBuilder.append(String.format(ONGOING_EVENT_MESSAGE, startTime.format(datetimeFormat), endTime.format(datetimeFormat)));
            createNewFreeTimeEntry(activeHourStart, activeHourEnd, TimeStatus.NOT_FREE);
            return true;
        }    
        if (activeHourStart.isAfter(startTime) && activeHourEnd.isBefore(endTime)) {
            createNewFreeTimeEntry(activeHourStart, activeHourEnd, TimeStatus.NOT_FREE);
            freetimeMsgBuilder.append(NO_FREE_TIME_MESSAGE).toString();
            return true;
        }     
        return false;
    }
    


    private String freetimeForMutipleEvents(LocalDateTime startTime, LocalDateTime endTime, LocalDateTime searchedDay) {
        int same_day = searchedDay.getDayOfMonth();
        freetimeMsgBuilder.append(String.format(DEFAULT_STARTING_MESSAGE, searchedDay.format(dateFormat)));
        LocalDateTime currentStartTime = startTime;
        LocalDateTime currentEndTime = endTime;    
        if (hasNoFreetime(startTime, endTime, searchedDay.getDayOfMonth())) {
            return freetimeMsgBuilder.toString();
        }
        if (activeHourStart.isBefore(currentStartTime)) {
            createNewFreeTimeEntry(activeHourStart, currentStartTime, TimeStatus.FREE);
        }
        if (activeHourEnd.isBefore(currentEndTime)) {
            return freetimeMsgBuilder.append(String.format(NUM_OF_FREESLOT_MESSAGE, noOfFreeSlot)).toString();
        }
        if (activeHourStart.isAfter(currentEndTime)) {
            currentEndTime = activeHourStart;
        }
        return getAllFreeSlot(currentEndTime);
    }

    private String getAllFreeSlot(LocalDateTime currentEventEndTime) {
        boolean checkFreeTime = false;
        LocalDateTime tempCurrentEventEndTime = currentEventEndTime;
        LocalDateTime nextEventStartTime;
        LocalDateTime nextEventEndTime; 
        for (int timeIndex = 1; timeIndex < timeLists.size(); timeIndex++) {
            nextEventStartTime = timeLists.get(timeIndex).getKey();
            nextEventEndTime = timeLists.get(timeIndex).getValue();
            if (tempCurrentEventEndTime.isAfter(nextEventStartTime) || tempCurrentEventEndTime.isEqual(nextEventStartTime)) {
                tempCurrentEventEndTime = getNextEndTime(tempCurrentEventEndTime, timeLists.get(timeIndex).getValue());
                continue;
            }
            createNewFreeTimeEntry(tempCurrentEventEndTime, nextEventStartTime, TimeStatus.FREE);
            if (activeHourEnd.isBefore(nextEventEndTime)) {
                return freetimeMsgBuilder.append(String.format(NUM_OF_FREESLOT_MESSAGE, noOfFreeSlot)).toString();
            }
            tempCurrentEventEndTime = nextEventEndTime;     
            if (hasFreetime() == checkFreeTime) {
                continue;
            }
            checkFreeTime = true;
        }
        return getAllFreeSlotMsg(activeHourEnd, tempCurrentEventEndTime, checkFreeTime);
    }
    
    public String getAllFreeSlotMsg(LocalDateTime activeHoursEnd, LocalDateTime currEventEndTime, boolean hasFreeTime) {    
        if (activeHoursEnd.isBefore(currEventEndTime) || activeHoursEnd.equals(currEventEndTime)) {
            return HAS_FREE_TIME == hasFreeTime ? freetimeMsgBuilder.toString() : noFreeTimeForMutipleEvent(freetimeMsgBuilder);
        }
        createNewFreeTimeEntry(currEventEndTime, activeHoursEnd, TimeStatus.FREE);
        return freetimeMsgBuilder.append(String.format(NUM_OF_FREESLOT_MESSAGE, noOfFreeSlot)).toString();
    }

    public String noFreeTimeForMutipleEvent(StringBuilder sb) {
        createNewFreeTimeEntry(activeHourStart, activeHourEnd, TimeStatus.NOT_FREE);
        return sb.append(NO_FREE_TIME_MESSAGE).toString();
    }

    public void increaseNoOfFreeSlot() {
        noOfFreeSlot++;
    }

    private void getAllEvent(List<ReadOnlyTask> filteredList) {
        for (int listIndex = 0; listIndex < filteredList.size(); listIndex++) {
            if (!(filteredList.get(listIndex) instanceof Event)) {
                continue;
            }
            Event event = (Event) filteredList.get(listIndex);
            if (event.getDoneStatus() == DONE) {
                continue;
            }
            LocalDateTime startDate = roundUpTime(event.getStartDate());
            LocalDateTime endDate = roundUpTime(event.getEndDate());
            createNewFreeTimeEntry(startDate, endDate, TimeStatus.NOT_FREE);
            Pair<LocalDateTime, LocalDateTime> datePair = new Pair<LocalDateTime, LocalDateTime>(startDate, endDate);
            timeLists.add(datePair);
        }
    }

    private LocalDateTime roundUpTime(LocalDateTime dateTime) {
        int minutes = dateTime.getMinute();
        if (minutes == EXACT_AN_HOUR) {
            return dateTime;
        }
        if (minutes <= HALF_AN_HOUR) {
            return dateTime.plusMinutes(HALF_AN_HOUR - minutes);
        }
        return dateTime.plusMinutes(AN_HOUR - minutes);

    }

    private boolean checkOnGoingEvent(int startDay, int endDay, int checkDay) {
        return startDay != checkDay && endDay != checkDay;
    }

    private LocalDateTime getNextEndTime(LocalDateTime currEndTime, LocalDateTime nextEndTime) {
        if (nextEndTime.isAfter(currEndTime)) {
            return nextEndTime;
        }
        return currEndTime;
    }

    public boolean hasFreetime() {
        return true;
    }

    private int convertTimeIntoInt(LocalDateTime dateToConvert) {
        int hour = dateToConvert.getHour();
        int totalMinutes = (hour * AN_HOUR) + dateToConvert.getMinute();
        return totalMinutes / HALF_AN_HOUR;
    }

    private void createNewFreeTimeEntry(LocalDateTime startDate, LocalDateTime endDate, TimeStatus status) {
        int startDay = startDate.getDayOfMonth();
        int endDay = endDate.getDayOfMonth();

        int start = convertTimeIntoInt(startDate);
        int end = convertTimeIntoInt(endDate);

        if (end == 0 && startDay != endDay) {
            end = LAST_TIME_BLOCK;
        }
        freeTimes.put(new Pair<Integer, Integer>(start, end), status);
        if (status.equals(TimeStatus.FREE)) {
            increaseNoOfFreeSlot();
        }
    }
    

    // sorting the list by start time
    private void sortEventList() {
        Collections.sort(timeLists, new Comparator<Pair<LocalDateTime, LocalDateTime>>() {
            public int compare(Pair<LocalDateTime, LocalDateTime> dateTimeOne,
                    Pair<LocalDateTime, LocalDateTime> dateTimeTwo) {
                return dateTimeOne.getKey().compareTo(dateTimeTwo.getKey());
            }

        });
    }

    /**
     * Returns a Map of timestatus representing the status of each timeslot.
     * Each pair represents a time slot, with the integer 0 representing 0000
     * hrs to 48 representing 2359 hrs. Each integer is 30 minutes.
     * <p>
     * 
     * 0 -> 1 : 0000 hrs to 0030 hrs.
     * <p>
     * Slots not in the map are assumed to be outside active hours
     * 
     */
    public Map<Pair<Integer, Integer>, TimeStatus> getFreeTimeLine() {
        return freeTimes;
    }

    public enum TimeStatus {
        FREE, NOT_FREE, OUTSIDE_ACTIVE_HRS;
    }
}
```
###### \java\seedu\address\logic\filters\NameQualifier.java
``` java
/**
 *
 * 
 * A general qualifier used by the filteredList wrapper to filter tasks
 * according to user's input. Return a true if task is found , false if task is not found
 * 
 * @params args : searchType, keywords, markFilter
 * @return boolean statement depending on if a task is found
 */
public class NameQualifier implements Qualifier {
    
    public static final String FILTER_BY_DAY = "DAY";
    public static final String SEARCH_NAME = "NAME";
    public static final String SEARCH_DESC = "DESC";
    public static final String SEARCH_TAG = "TAG";
    public static final String SEARCH_TYPE = "TYPE";
    public static final String SEARCH_TYPE_ALL = "all";
    public static final String SEARCH_TYPE_MARK = "mark";

    private static final boolean TASK_NOT_FOUND = false;
    private static final boolean TASK_FOUND = true;
    private static final boolean MARKED_TASK = true;
    private static final boolean IS_SAME_DAY = true;
    private static final boolean MARK_NOT_FILTERED = false;
    private static final int LAST_DAY_INDEX = 7;


    private static final int ARGS_INDEX = 0;
    private static final int LOCAL_DATE_INDEX = 0;
    private static final int GET_TO_MONDAY_INDEX = 1;
    private static final int OVERDUE_TASK = -1;

    private Set<String> nameKeyWords;
    private String typeOfFind;
    private ArrayList<LocalDate> localDateLists;
    private ArrayList<LocalDateTime> dateToCompareLists;
    private boolean isMarkCheck;

    public NameQualifier(Set<String> nameKeyWords, String typeOfFind, boolean isMarkCheck) {
        this.localDateLists = new ArrayList<LocalDate>();
        this.dateToCompareLists = new ArrayList<LocalDateTime>();
        this.nameKeyWords = nameKeyWords;
        this.typeOfFind = typeOfFind;
        this.isMarkCheck = isMarkCheck;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        if (isTypeSearch(typeOfFind)) {
            return filterByType(task);
        }
        if (isMarkCheck == MARK_NOT_FILTERED && task.getDoneStatus() == MARKED_TASK) {
            return TASK_NOT_FOUND;
        }
        if (isKeywordSearch(typeOfFind)) {
            Trie keywordTrie = buildKeyword();
            return filterByKeyWord(task, keywordTrie, typeOfFind);
        }
        getDateForCompare();
        getLocalDate();
        if (task instanceof Deadline) {
            return filterDeadLine(task);
        }
        if (task instanceof Event) {
            return filterEvent(task);
        }
        return TASK_FOUND;

    }

    private boolean isTypeSearch(String searchType) {
        return searchType.equals(SEARCH_TYPE);
    }

    private boolean isKeywordSearch(String searchType) {
        return searchType.equals(SEARCH_NAME) || searchType.equals(SEARCH_TAG) || searchType.equals(SEARCH_DESC);
    }

    private Trie buildKeyword() {
        List<String> keywordList = new ArrayList<String>(nameKeyWords);
        TrieBuilder trie = Trie.builder();
        for (int keyword_index = 0; keyword_index < keywordList.size(); keyword_index++) {
            String keyword = keywordList.get(keyword_index);
            trie.addKeyword(keyword);

        }
        return trie.caseInsensitive().removeOverlaps().build();
    }

    private boolean filterByType(ReadOnlyTask task) {
        List<String> findTypeList = new ArrayList<String>(nameKeyWords);
        String findType = findTypeList.get(ARGS_INDEX);
        if (SEARCH_TYPE_ALL.equalsIgnoreCase(findType)) {
            return TASK_FOUND;
        }

        if (SEARCH_TYPE_MARK.equalsIgnoreCase(findType)) {
            return task.getDoneStatus() == MARKED_TASK;
        }

        return filterByOverdue(task);
    }

    private boolean filterByOverdue(ReadOnlyTask task) {
        if (task.getDoneStatus() == MARKED_TASK) {
            return TASK_NOT_FOUND;
        }
        LocalDateTime now = LocalDateTime.now();
        if (task instanceof Deadline) {
            LocalDateTime endDate = ((Deadline) task).getEndDate();
            return endDate.compareTo(now) <= OVERDUE_TASK;
        }
        return TASK_NOT_FOUND;
    }

    private boolean filterByKeyWord(ReadOnlyTask task, Trie keywordTrie, String searchType) {
        if (searchType.equals(SEARCH_NAME)) {
            return keywordTrie.containsMatch(task.getName());
        }
        if (searchType.equals(SEARCH_DESC)) {
            return keywordTrie.containsMatch(task.getDescription());
        }
        return filterByTag(task, keywordTrie);
    }

    private boolean filterByTag(ReadOnlyTask task, Trie keywordTrie) {
        UniqueTagList tagList = task.getTags();
        for (Tag tag : tagList) {
            if (keywordTrie.containsMatch(tag.tagName)) {
                return TASK_FOUND;
            }
        }
        return TASK_NOT_FOUND;
    }

    public boolean filterDeadLine(ReadOnlyTask deadline) {
        LocalDate deadlineEndDate = ((Deadline) deadline).getEndDate().toLocalDate();
        if ("DAY".equals(typeOfFind)) {
            return localDateLists.get(LOCAL_DATE_INDEX).equals(deadlineEndDate) == IS_SAME_DAY;
        }
        for (int dayIndex = 0; dayIndex < LAST_DAY_INDEX; dayIndex++) {
            if (localDateLists.get(dayIndex).equals(deadlineEndDate) == IS_SAME_DAY) {
                return TASK_FOUND;
            }
        }
        return TASK_NOT_FOUND;
    }

    /**
     * filter out event that start or end on that particular date filter out
     * ongoing event that is happening during that particular date
     */
    public boolean filterEvent(ReadOnlyTask event) {
        LocalDate eventStartDate = ((Event) event).getStartDate().toLocalDate();
        LocalDate eventEndDate = ((Event) event).getEndDate().toLocalDate();
        LocalDate dateToCompare;
        if (FILTER_BY_DAY.equals(typeOfFind)) {
            dateToCompare = localDateLists.get(LOCAL_DATE_INDEX);
            return checkEvent(dateToCompare, eventStartDate, eventEndDate);

        }
        for (int dayIndex = 0; dayIndex < LAST_DAY_INDEX; dayIndex++) {
            dateToCompare = localDateLists.get(dayIndex);
            if (checkEvent(dateToCompare, eventStartDate, eventEndDate)) {
                return TASK_FOUND;
            }
        }
        return TASK_NOT_FOUND;
    }

    private boolean checkEvent(LocalDate comparedDate, LocalDate startDate, LocalDate endDate) {
        if (isEventFound(comparedDate, startDate, endDate)) {
            return TASK_FOUND;
        }
        return TASK_NOT_FOUND;
    }
    
    private boolean isEventFound(LocalDate comparedDate, LocalDate startDate, LocalDate endDate) {
        return comparedDate.equals(startDate) == IS_SAME_DAY || comparedDate.equals(endDate) == IS_SAME_DAY
                || (comparedDate.isAfter(startDate) && comparedDate.isBefore(endDate));
    }

    private void getLocalDate() {
        for (int date_index = 0; date_index < dateToCompareLists.size(); date_index++) {
            LocalDate convertToDate = dateToCompareLists.get(date_index).toLocalDate();
            localDateLists.add(convertToDate);
        }

    }
    
    /*
     * @return a list of size one containing the searchedDay if searchType is "DAY", 
     * or return a list of dates from Monday to Friday on that searchedWeek if searchType is "Week"
     */

    public void getDateForCompare() {
        LocalDateTime dateToday = LocalDateTime.now();
        LocalDateTime dateForCompare = dateToday;
        Long timeToAdd = parseTimeToLong(nameKeyWords);
        if (FILTER_BY_DAY.equals(typeOfFind)) {
            dateForCompare = dateToday.plusDays(timeToAdd);
            dateToCompareLists.add(dateForCompare);
            return;
        }
        LocalDateTime startOfTheWeek = getToDesiredWeek(timeToAdd, dateToday);
        for (int day_index = 0; day_index < LAST_DAY_INDEX; day_index++) {
            dateForCompare = startOfTheWeek.plusDays(day_index);
            dateToCompareLists.add(dateForCompare);
        }

    }
    

    public LocalDateTime getToDesiredWeek(Long addedTime, LocalDateTime now) {
        LocalDateTime dateOfThatWeek = now.plusWeeks(addedTime);
        int dayOfThatWeek = dateOfThatWeek.getDayOfWeek().getValue();
        LocalDateTime previousWeek = dateOfThatWeek.minusDays(dayOfThatWeek);
        return previousWeek.plusDays(GET_TO_MONDAY_INDEX);
    }

    public Long parseTimeToLong(Set<String> nameKeyWords) {
        List<String> getTimeList = new ArrayList<String>(nameKeyWords);
        return Long.parseLong(getTimeList.get(ARGS_INDEX));
    }

    @Override
    public String toString() {
        return "name=" + String.join(", ", nameKeyWords);
    }
}
```
###### \java\seedu\address\logic\parser\CdCommandParser.java
``` java
public class CdCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        String commandType = getType(args.trim());
        try {
            return new CdCommand(args.trim(), commandType);
        } catch (IllegalValueException e) {
            return new IncorrectCommand((e.getMessage() + "\n" + CdCommand.MESSAGE_USAGE));
        } catch (ParseException e) {
            return new IncorrectCommand(CdCommand.MESSAGE_FAILURE_PARSE);
        } catch (IOException e) {
            return new IncorrectCommand(CdCommand.MESSAGE_FAILURE_PARSE);
        }

    }

    public String getType(String args) {
        if (args.isEmpty()) {
            return CdCommand.CD_CHECK;
        }
        return CdCommand.CD_CHANGE;
    }

}
```
###### \java\seedu\address\logic\parser\FindCommandParser.java
``` java
/*
 * parsing arguments and prepare them for find command
 */
public class FindCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args  full command args string
     *           
     * @return the prepared command
     */
    private static final String EMPTY_STRING = "";
    private static final String SEPERATOR = "/";
    private static final String CHECK_TRUE = "true";
    private static final String NULL_STRING = null;
    private static final int VALID_FIND_TYPE_NUMBER = 1;
    private  static final int FIND_TYPE_INDEX = 0;
    private static final boolean INCLUDE_MARK = true;
    private  static final boolean EXCLUDE_MARK = false;
    private ArgumentsParser parser;
    
    @Override
    public Command prepareCommand(String args) {
 
        try {
            parser = prepareParser(args);
            parser.parse(args);
            final boolean checkMark = prepareMarkArgs();
            final String typeOfFind = prepareTypeOfFind();
            if (!isValidArgs(typeOfFind, args.trim())) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
            }
            final Set<String> keywordSet = prepareSets(typeOfFind);
            return new FindCommand(keywordSet, typeOfFind, checkMark);
        } catch (IncorrectCommandException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }

    private Set<String> prepareSets(String typeOfFind) throws IncorrectCommandException {
        final String[] keywords = getKeywords(typeOfFind);
        final Set<String> preparedKeywordSet = Sets.newHashSet(Arrays.asList(keywords));
        preparedKeywordSet.remove(EMPTY_STRING);
        return preparedKeywordSet;
    }

    private ArgumentsParser prepareParser(String argsToParse) throws IncorrectCommandException {
        ArgumentsParser prepareParser = new ArgumentsParser();
        prepareParser.addOptionalArg(CommandArgs.FIND_NAME)
        .addOptionalArg(CommandArgs.FIND_WEEK)
        .addOptionalArg(CommandArgs.FIND_DAY)
        .addOptionalArg(CommandArgs.FIND_DESC)
        .addOptionalArg(CommandArgs.FIND_TAG)
        .addOptionalArg(CommandArgs.FIND_MARK)
        .addOptionalArg(CommandArgs.FIND_TYPE);
        return prepareParser;
    }

    // To check that users does not enter anything between find command and
    // search type
    // eg. find abcd all/KEYWORDS
    private boolean isValidArgs(String typeOfFind, String args) {
        int compareCharAt;
        for (compareCharAt = 0; compareCharAt < typeOfFind.length(); compareCharAt++) {
            char findType_char = typeOfFind.toLowerCase().charAt(compareCharAt);
            char args_char = args.toLowerCase().charAt(compareCharAt);
            if (findType_char != args_char) {
                return false;
            }
        }

        int seperatorIndex = compareCharAt++;
        return args.startsWith(SEPERATOR, seperatorIndex);
    }

    public String prepareTypeOfFind() throws IncorrectCommandException {
        String name = getNameArg();
        String week = getWeekArg();
        String day = getDayArg();
        String desc = getDescArg();
        String tag = getTagArg();
        String type = getTypeArg();
        return getTypeOfFind(name, week, day, desc, tag, type);

    }

    private boolean prepareMarkArgs() throws IncorrectCommandException {
        String markArgs = getMarkArg();
        if (CHECK_TRUE.equalsIgnoreCase(markArgs)) {
            return INCLUDE_MARK;
        }
        if (EMPTY_STRING.equals(markArgs)) {
            return EXCLUDE_MARK;
        }
        throw new IncorrectCommandException();
    }

    private String getMarkArg() {
        if (!parser.getArgValue(CommandArgs.FIND_MARK).isPresent()) {
            return EMPTY_STRING;
        }
        return parser.getArgValue(CommandArgs.FIND_MARK).get();
    }

    private String getTagArg() {
        return parser.getArgValue(CommandArgs.FIND_TAG).isPresent() ? "TAG" : EMPTY_STRING;
    }

    private String getDescArg() {
        return parser.getArgValue(CommandArgs.FIND_DESC).isPresent() ? "DESC" : EMPTY_STRING;
    }

    private String getDayArg() {
        return parser.getArgValue(CommandArgs.FIND_DAY).isPresent() ? "DAY" : EMPTY_STRING;
    }

    private String getWeekArg() {
        return parser.getArgValue(CommandArgs.FIND_WEEK).isPresent() ? "WEEK" : EMPTY_STRING;
    }

    private String getNameArg() {
        return parser.getArgValue(CommandArgs.FIND_NAME).isPresent() ? "NAME" : EMPTY_STRING;
    }

    private String getTypeArg() {
        return parser.getArgValue(CommandArgs.FIND_TYPE).isPresent() ? "TYPE" : EMPTY_STRING;
    }

    public String getTypeOfFind(String... args) throws IncorrectCommandException {
        List<String> typeOfFind = new ArrayList<String>(Arrays.asList(args));
        typeOfFind.removeAll(Arrays.asList(EMPTY_STRING, NULL_STRING));
        if (typeOfFind.size() != VALID_FIND_TYPE_NUMBER) {
            throw new IncorrectCommandException();
        }
        return typeOfFind.get(FIND_TYPE_INDEX);
    }

    public String[] getKeywords(String typeOfFind) throws IncorrectCommandException {
        switch (typeOfFind) {
        case "NAME":
            return parser.getArgValue(CommandArgs.FIND_NAME).get().split("\\s+");
        case "WEEK":
            return parser.getArgValue(CommandArgs.FIND_WEEK).get().split("\\s+");
        case "DAY":
            return parser.getArgValue(CommandArgs.FIND_DAY).get().split("\\s+");
        case "DESC":
            return parser.getArgValue(CommandArgs.FIND_DESC).get().split("\\s+");
        case "TAG":
            return parser.getArgValue(CommandArgs.FIND_TAG).get().split("\\s+");
        case "TYPE":
            if (parser.getArgValue(CommandArgs.FIND_MARK).isPresent()) {
                throw new IncorrectCommandException();
            }
            return parser.getArgValue(CommandArgs.FIND_TYPE).get().split("\\s+");
        default:
            throw new IncorrectCommandException();
        }

    }

}
```
###### \java\seedu\address\logic\parser\FreetimeCommandParser.java
``` java
/*
 *  parsing arguments and prepare them for freetime command
 */
// 
public class FreetimeCommandParser extends CommandParser {
    /**
     * Parses argument in the context of the freetime command
     * 
     * @param full command args string
     * @return the prepared command
     */
    private static final String SEARCH_TYPE = "day";
    private static final String SEPERATOR = "/";
    private static final boolean INVALID_ARGS = false;
    private static final boolean VALID_ARGS = true;
    private static final String EMPTY_STRING = "";
    private static final String DEFAULT_FREETIME_DAY = "0";
    private ArgumentsParser parser;

    @Override
    public Command prepareCommand(String args) {
        if (args.trim().equals(EMPTY_STRING)) {
            return new FreetimeCommand(DEFAULT_FREETIME_DAY);
        }
        prepareParser();
        if (!isValidArgs(SEARCH_TYPE, args.trim())) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FreetimeCommand.MESSAGE_USAGE));
        }
        try {
            parser.parse(args);
        } catch (IncorrectCommandException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FreetimeCommand.MESSAGE_USAGE));
        }
        String parsedArgs = parser.getArgValue(CommandArgs.FIND_DAY).get().trim();
        if (!checkValidInt(parsedArgs)) {
            return new IncorrectCommand(
                    String.format(FreetimeCommand.INVALID_FREETIME_ARGS, FreetimeCommand.MESSAGE_USAGE));
        }
        return new FreetimeCommand(parsedArgs);
    }

    private void prepareParser() {
        parser = new ArgumentsParser();
        parser.addOptionalArg(CommandArgs.FIND_DAY);

    }

    private boolean isValidArgs(String searchType, String args) {
        int compareCharAt;
        char searchType_char;
        char args_char;
        int seperatorIndex = searchType.length();
        for (compareCharAt = 0; compareCharAt < searchType.length(); compareCharAt++) {
            searchType_char = searchType.toLowerCase().charAt(compareCharAt);
            args_char = args.toLowerCase().charAt(compareCharAt);
            if (searchType_char != args_char) {
                return INVALID_ARGS;
            }
        }
        return args.startsWith(SEPERATOR, seperatorIndex);
    }

    public boolean checkValidInt(String parsedArg) {
        try {
            Integer.parseInt(parsedArg);
        } catch (NumberFormatException e) {
            return INVALID_ARGS;
        }
        return VALID_ARGS;
    }

}
```
###### \resources\view\Help.html
``` html
<ul>
<li><p><code>confirm 5 st/6pm et/8pm</code><br /></p>
<h4>Searching for (a) specific task(s): <code>find</code></h4>
<p>Finds tasks of a specific time, or whose names contain any of the given keywords.<br />Format: <code>find METHOD/ KEYWORDS [mark/TRUE]</code><br />KEYWORDS for TYPE 'name/' 'desc/' 'tag/' is a word that is contain/part of a task name/description/tag<br />KEYWORDS for TYPE 'day' and 'week' is a integer number.</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Explanation</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>day/</code></td>
<td align="left">List all events/deadline a number of days after today</td>
<td align="left"><code>find day/ -1</code> (yesterday)</td>
</tr>
<tr class="even">
<td align="left"><code>week/</code></td>
<td align="left">List all events/deadline in a week, after current week</td>
<td align="left"><code>find week/ 0</code> (current week)</td>
</tr>
<tr class="odd">
<td align="left"><code>name/</code></td>
<td align="left">List all tasks with taskName containing the keywords</td>
<td align="left"><code>find name/ shoes</code></td>
</tr>
<tr class="even">
<td align="left"><code>tag/</code></td>
<td align="left">List all tasks with taskDescription containing the keywords</td>
<td align="left"><code>find name/ shoes</code></td>
</tr>
<tr class="odd">
<td align="left"><code>desc/</code></td>
<td align="left">List all tasks with the tags of task containing the keywords</td>
<td align="left"><code>find name/ shoes</code></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>The search is not case sensitive. e.g <code>task</code> will match <code>TaSK</code><br /></li>
<li>The order of the keywords does not matter. e.g. <code>is s task</code> will match <code>task is a</code><br /></li>
<li>Sub-words will be matched e.g. <code>sk</code> will match <code>task</code><br /></li>
<li>Tasks matching at least one keyword will be returned (i.e. <code>OR</code> search).</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FindCommand filtered out marked tasks automatically, user can turn off filter by using [mark/TRUE]<br />to include marked task in search</li>
</ul>
</blockquote>
<ul>
<li>'find name/i wan to find marked task mark/true'</li>
</ul>
<h4 id="searching-for-a-specific-tasks-under-certain-category-find">Searching for (a) specific task(s) under certain category: 'find'</h4>
<p>Find tasks that belong to a certain category.<br />Format: 'find TYPE/CATEGORY'<br />'CATEGORY' is defined as 'all', 'overdue', 'mark'. Any other category will be classified<br />as invalidCommand.</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Explanation</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">'type/all'</td>
<td align="left">List out every task stored in the save data</td>
<td align="left">'find type/all'</td>
</tr>
<tr class="even">
<td align="left">'type/overdue'</td>
<td align="left">List out all deadline that are overdue and not marked</td>
<td align="left">'find type/overdue'</td>
</tr>
<tr class="odd">
<td align="left">'type/mark'</td>
<td align="left">List out all tasks that are marked done</td>
<td align="left">'find type/mark'</td>
</tr>
</tbody>
</table>
```
###### \resources\view\Help.html
``` html

<h4 id="finding-free-time-in-a-specific-day-freetime">Finding free time in a specific day: <code>freetime</code></h4>
<p>Gives you all the free time blocks in a specific day<br />Format: <code>freetime [day/DAYS_FROM_TODAY]</code></p>
<blockquote>
<ul>
<li>By default, freetime gives you today's free time<br /></li>
<li>You can adjust days by using the day/ option<br /></li>
<li>For example, for yesterday's free time, <code>freetime day/-1</code><br /></li>
<li>DAYS_FROM_TODAY <strong>must be an integer</strong></li>
</ul>
</blockquote>
```
###### \resources\view\Help.html
``` html

<h4 id="changing-filestorage-location-cd">Changing FileStorage location : <code>cd</code></h4>
<p>Changing the saveData into another location <br><br />Format: <code>cd [FILEPATH\FILENAME.xml]</code><br />Examples:</p>
<ul>
<li><code>cd</code> will tell you the current location of the saveData<br /></li>
<li><code>cd C:\Users\Boon\newSaveName.xml</code>will change the saveData location to specified path</li>
</ul>
```
