# A0135768R
###### \java\seedu\address\commons\core\Config.java
``` java
/**
 * A class that contains the config values used by the app. If initalized, this
 * class will be loaded with the saved values in config.json
 * 
 */
public class Config {

    public static final String DEFAULT_CONFIG_FILE = "config.json";

    @JsonIgnore
    private static final Map<String, Pair<Class<?>, Object>> DEFAULT_CONFIGS = Maps.newHashMap();

    // Config values customizable through config file
    private Map<String, Object> configRegistry = Maps.newHashMap();

    static {

        Config.<String>registerNewConfigWithDefault("appTitle", "Task Force");
        Config.<String>registerNewConfigWithDefault("userPrefsFilePath", "preferences.json");
        Config.<String>registerNewConfigWithDefault("taskForceDataFilePath", "data/taskForceData.xml");
        Config.<String>registerNewConfigWithDefault("appName", "My Todo list");
        Config.<String>registerNewConfigWithDefault("activeHoursFrom", "0800");
        Config.<String>registerNewConfigWithDefault("activeHoursTo", "2100");
        Config.<Boolean>registerNewConfigWithDefault("enableSudo", false);

    }

    private static <T> void registerNewConfigWithDefault(String key, T value) {
        DEFAULT_CONFIGS.put(key, new Pair<Class<?>, Object>(value.getClass(), value));
    }

    public static Class<?> getConfigValueType(String configOption) {
        return (DEFAULT_CONFIGS.get(configOption) != null) ? DEFAULT_CONFIGS.get(configOption).getKey() : null;
    }

    public Config() {
        resetAndregisterDefaultConfigs();
    }

    public void resetAndregisterDefaultConfigs() {
        configRegistry.clear();

        for (Entry<String, Pair<Class<?>, Object>> entry : DEFAULT_CONFIGS.entrySet()) {

            Class<?> clazz = entry.getValue().getKey();
            Object value = entry.getValue().getValue();

            configRegistry.put(entry.getKey(), clazz.cast(value));

        }
    }

    public <T> void setConfigurationOption(String key, T value) {

        if (DEFAULT_CONFIGS.containsKey(key)) {
            configRegistry.put(key, value);

        } else {
            configRegistry.replace(key, value);
        }
    }

    public <T> T getConfigurationOption(String key) {
        if (!configRegistry.containsKey(key)) {
            return (T) DEFAULT_CONFIGS.get(key).getValue();
        }

        return (T) configRegistry.get(key);
    }

    public ImmutableMap<String, Pair<Class<?>, Object>> getDefaultConfigs() {
        return ImmutableMap.copyOf(DEFAULT_CONFIGS);
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }
        if (!(other instanceof Config)) { // this handles null as well.
            return false;
        }

        Config o = (Config) other;

        return configRegistry.equals(o.configRegistry);
    }

    @Override
    public int hashCode() {
        return configRegistry.hashCode();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        for (Entry<String, Object> entry : configRegistry.entrySet()) {
            sb.append(entry.getKey() + ": " + entry.getValue());
            sb.append("\n");
        }

        return sb.toString();
    }

    public static String getDefaultConfigString() {
        Config config = new Config();

        return config.toString();
    }

    // The getter and setters are left alone for minimal code impact
```
###### \java\seedu\address\commons\events\model\TaskForceCommandExecutedEvent.java
``` java
/**
 *
 *          <p>
 *          This event is fired right after a command is executed.
 * 
 */
public class TaskForceCommandExecutedEvent extends BaseEvent {

    public final Command commandInstance;
    public final CommandResult result;

    public TaskForceCommandExecutedEvent(Command commandInstance, CommandResult result) {
        this.commandInstance = commandInstance;
        this.result = result;

    }

    @Override
    public String toString() {
        return "Command Executed: " + commandInstance.getClass().getSimpleName() + ". Command Success:"
                + result.isSuccessfulCommand();
    }

}
```
###### \java\seedu\address\commons\util\DateUtil.java
``` java
public final class DateUtil {

    public static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy hh:mm a");

    public static final LocalDateTime NOW = LocalDateTime.now();
    public static final LocalDateTime END_OF_TODAY = NOW.withHour(23).withMinute(59);
    public static final LocalDateTime MARKER_FOR_DELETE = LocalDateTime.MIN;

    public static final String STRING_FOR_DELETE = "-";

    private static final Parser NATTY_PARSER_INSTANCE = new Parser();

    /**
     * Passes the natural language date string to the Natty's library for
     * parsing. If the date string provided is not valid (or not parsable by
     * Natty), this will return {@code Optional.empty()}
     */
    public static Optional<LocalDateTime> parseStringIntoDateTime(String rawString) {

        if (rawString == null) {
            return Optional.empty();
        }

        if (rawString.equals(STRING_FOR_DELETE)) {
            return Optional.of(MARKER_FOR_DELETE);
        }

        List<DateGroup> dates = NATTY_PARSER_INSTANCE.parse(rawString);

        try {
            Date date = dates.get(0).getDates().get(0);

            return Optional.of(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()));

        } catch (IndexOutOfBoundsException e) {
            return Optional.empty();
        }
    }

    public static String parseLocalDateTimeIntoString(LocalDateTime datetime) {
        assert datetime != null;

        return datetime.format(FORMATTER);
    }

    /**
     * Given a new event that is being added/to be added to the model, checks
     * that if any events currently in the model that will conflict with the
     * given event. If the given event is already added to the model, it will be
     * ignored - that is an event cannot conflict with itself.
     * 
     * @param model
     *            The model of the TaskForce - cannot be null.
     * @param eventToBeAdded
     *            The event that is being added/or already added to the model.
     * @return {@link Optional.empty()} if there is no conflict; otherwise an
     *         arbitrary conflicting event is returned.
     */
    public static Optional<Event> checkForConflictingEvents(Model model, Event eventToBeAdded) {
        assert model != null;

        LocalDateTime startTime = eventToBeAdded.getStartDate();
        LocalDateTime endTime = eventToBeAdded.getEndDate();

        assert startTime.isBefore(endTime);

        Long days = ChronoUnit.DAYS.between(startTime, endTime);

        model.searchTaskList(new PredicateExpression(
                new NameQualifier(Sets.newHashSet(days.toString()), NameQualifier.FILTER_BY_DAY, false)));

        PriorityQueue<Event> eventQueue = new PriorityQueue<>(new EventComparator());

        for (ReadOnlyTask task : model.getSearchedTaskList()) {

            if (!(task instanceof Event) || task.equals(eventToBeAdded)) {
                continue;
            }

            eventQueue.add((Event) task);

        }

        // Don't need to do anything if there is no events occuring on this time
        // period
        if (eventQueue.isEmpty()) {
            return Optional.empty();
        }

        Event event = eventQueue.poll();

        while (event != null && event.getEndDate().isAfter(startTime)) {

            if (event.getStartDate().isBefore(endTime)) {
                return Optional.of(event);
            }

            event = eventQueue.poll();
        }

        return Optional.empty();

    }

    private static Optional<Pair<LocalDateTime, LocalDateTime>> determineStartAndEndDateTime(
            Optional<LocalDateTime> startDate, Optional<LocalDateTime> endDate, boolean isEmptyAllowed) {

        LocalDateTime computedStartDate;
        LocalDateTime computedEndDate;

        if (!startDate.isPresent() && !endDate.isPresent()) {
            return Optional.empty();
        }

        if (!isEmptyAllowed && (!startDate.isPresent() || !endDate.isPresent())) {
            return Optional.empty();
        }

        if (!startDate.isPresent() || !endDate.isPresent()) {
            computedStartDate = startDate.orElse(DateUtil.NOW);
            computedEndDate = endDate.orElse(computedStartDate.withHour(23).withMinute(59));

            return Optional.of(new Pair<LocalDateTime, LocalDateTime>(computedStartDate, computedEndDate));
        }

        if (endDate.get().isBefore(startDate.get()) && isDateComponentSameAsNow(endDate.get())) {
            computedStartDate = startDate.get();

            int seconds = endDate.get().getSecond();
            int minutes = endDate.get().getMinute();
            int hours = endDate.get().getHour();

            computedEndDate = startDate.get().withHour(hours).withMinute(minutes).withSecond(seconds);

            if (computedStartDate.isBefore(computedEndDate)) {
                return Optional.of(new Pair<LocalDateTime, LocalDateTime>(computedStartDate, computedEndDate));
            }

        } else if (endDate.get().isAfter(startDate.get())) {

            return Optional.of(new Pair<LocalDateTime, LocalDateTime>(startDate.get(), endDate.get()));

        }

        return Optional.empty();

    }

    /**
     * Given one and start and end date, the function will return a
     * corresponding start and end dates following these rules:
     * <p>
     * 
     * - If both dates are empty, it will return Optional.empty <br>
     * - If only start date is empty, the start date shall assumed to be now.
     * <br>
     * - If only end date is empty, the end date shall be assumed to be on the
     * same day of the start date at 2359 <br>
     * - If a start datetime is provided and only end time is provided, the end
     * datetime is assumed to be on the same day as the start date on the time
     * provided.
     * <p>
     * If start datetime happens to be after end datetime, this function will
     * return Optional.empty()
     * <p>
     * 
     * If the boolean isEmptyValuesAllowed is set to false, however, then if any
     * dates is empty, this will return {@link Optional.empty()} This is set to
     * true by default if not specified
     * 
     * <p>
     * 
     * @param startString
     *            string that will be parsed by natty
     * @param endString
     *            string that will be parsed by natty
     * @return a LocalDateTime pair with the key being the starting datetime,
     *         and the value the ending datetime
     */
    public static Optional<Pair<LocalDateTime, LocalDateTime>> determineStartAndEndDateTime(String startString,
            String endString) {
        return determineStartAndEndDateTime(parseStringIntoDateTime(startString), parseStringIntoDateTime(endString),
                true);
    }

    public static Optional<Pair<LocalDateTime, LocalDateTime>> determineStartAndEndDateTime(String startString,
            String endString, boolean isEmptyValuesAllowed) {
        return determineStartAndEndDateTime(parseStringIntoDateTime(startString), parseStringIntoDateTime(endString),
                isEmptyValuesAllowed);
    }

    private static boolean isDateComponentSameAsNow(LocalDateTime dateTime) {
        LocalDate now = LocalDate.now();
        LocalDate givenDate = dateTime.toLocalDate();

        return now.equals(givenDate);
    }

    public static String getRelativeDateFromNow(LocalDateTime dateTime) {
        Long milis = ChronoUnit.MILLIS.between(NOW, dateTime);

        return RelativeTimeConverter.toDuration(milis);
    }

    public static long getTimeDifferenceFromNow(LocalDateTime dateTime, ChronoUnit units) {
        long diff = units.between(NOW, dateTime);

        return diff;
    }

    // Comparator for priority queue
    private static class EventComparator implements Comparator<Event> {

        @Override
        public int compare(Event arg0, Event arg1) {
            LocalDateTime arg0Date = arg0.getEndDate();
            LocalDateTime arg1Date = arg1.getEndDate();

            if (arg0Date.isBefore(arg1Date)) {
                return 1;
            }

            if (arg0Date.isAfter(arg1Date)) {
                return -1;
            }

            return 0;
        }

    }

    private static class RelativeTimeConverter {

        public static final ImmutableList<Long> TIMES = ImmutableList.of(TimeUnit.DAYS.toMillis(365),
                TimeUnit.DAYS.toMillis(30), TimeUnit.DAYS.toMillis(1), TimeUnit.HOURS.toMillis(1),
                TimeUnit.MINUTES.toMillis(1), TimeUnit.SECONDS.toMillis(1));

        public static final ImmutableList<String> TIME_STIRNGS = ImmutableList.of("year", "month", "day", "hour",
                "minute", "second");

        public static String toDuration(long miliseconds) {

            long duration = Math.abs(miliseconds);

            StringBuffer buffer = new StringBuffer();

            for (int i = 0; i < TIMES.size(); i++) {
                Long current = TIMES.get(i);
                long temp = duration / current;

                if (temp > 0) {
                    buffer.append(temp);
                    buffer.append(" ");
                    buffer.append(TIME_STIRNGS.get(i));
                    buffer.append(temp > 1 ? "s" : "");

                    break;
                }
            }

            if ("".equals(buffer.toString())) {
                return "0 second ago";
            }

            if (miliseconds <= 0) {
                buffer.append(" ago");
            }

            return buffer.toString();
        }
    }
}
```
###### \java\seedu\address\commons\util\FxViewUtil.java
``` java
/**
 * 
 * 
 *          Contains utility methods for JavaFX views
 */
public class FxViewUtil {

    public static final ImmutableMap<String, NodeStyle> NODE_STYLES;

    static {

        Builder<String, NodeStyle> builder = ImmutableMap.builder();

        for (NodeStyle nodeStyle : NodeStyle.values()) {
            builder.put(nodeStyle.className, nodeStyle);
        }

        NODE_STYLES = builder.build();
    }

    public static void removeAndAddCssClass(Node node, String classToRemove, String classToAdd) {
        node.getStyleClass().remove(classToRemove);
        node.getStyleClass().add(classToAdd);
    }

    /**
     * Sets the style of the given node with the given style CSS class if it
     * satisfies the following rule :
     * <p>
     * 
     * - The given style has a integer priority lower or equals to all other CSS
     * classes of the same family currently applied to this node
     * 
     * @param node
     *            The node to apply the style to
     * @param style
     *            A NodeStyle representing the CSS class that is to be applied
     *            onto the given node
     */
    public static void setNodeStyle(Node node, NodeStyle style) {

        if (style == null) {
            return;
        }

        String family = style.family;

        List<String> classToRemove = new ArrayList<>();
        String classToAdd = style.className;

        for (String cssClass : node.getStyleClass()) {
            NodeStyle nodeStyle = NODE_STYLES.get(cssClass);
            
            if (nodeStyle == null) {
                continue ;
            }

            if (nodeStyle.shouldOverwriteStyle(style)) {
                classToRemove.add(nodeStyle.className);
            } else {
                classToAdd = null ;
            }
        }

        node.getStyleClass().removeAll(classToRemove);

        if (classToAdd != null) {
            node.getStyleClass().add(classToAdd);
        }

    }

```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    /**
     * 
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String description, String startDate, String endDate, Set<String> tags,
            String recurring, String repeat) throws IllegalValueException {

        setRecurrenceAttributes(recurring, repeat);

        if (startDate == null && endDate == null) {

            setNewTaskWithDetails(name, description, tags);

        } else if (startDate == null && endDate != null) {

            Optional<Pair<LocalDateTime, LocalDateTime>> datePair = DateUtil.determineStartAndEndDateTime(null,
                    endDate);
            setNewTaskWithDetails(name, description, datePair.get().getValue(), tags);

        } else if (startDate != null) {

            Pair<LocalDateTime, LocalDateTime> datePair = DateUtil.determineStartAndEndDateTime(startDate, endDate)
                    .orElseThrow(() -> new IllegalValueException(INVALID_END_DATE_MESSAGE));

            setNewTaskWithDetails(name, description, datePair.getKey(), datePair.getValue(), tags);

        } else {
            throw new IllegalValueException(INVALID_TASK_TYPE_MESSAGE);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        this.id = model.getNextTaskId();

        if (recurringFrequency != null && repeat == 0) {
            return new CommandResult(MISSING_NUMBER_OF_RECURRENCE_MESSAGE);
        }

        try {

            if (recurringFrequency != null && repeat >= MIN_NUMBER_OF_RECURRENCE) {
                this.createRecurringEvent(model, recurringFrequency, repeat);

            } else {
                this.taskList.add(getNewTask(model));
            }

        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage());
        }

        try {

            for (Task task : taskList) {
                model.addTask(task);
            }

            return new CommandResult(getAddCommandSuccessMessage(taskList), true);

        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }

    private void setNewTaskWithDetails(String name, String description, LocalDateTime startDate, LocalDateTime endDate,
            Set<String> tags) {
        this.name = name;
        this.description = description;
        this.startDate = startDate;
        this.endDate = endDate;
        this.tagNames = tags;
    }

    private void setNewTaskWithDetails(String name, String description, LocalDateTime endDate, Set<String> tags) {
        setNewTaskWithDetails(name, description, null, endDate, tags);
    }

    private void setNewTaskWithDetails(String name, String description, Set<String> tags) {
        setNewTaskWithDetails(name, description, null, null, tags);
    }

    private Task getNewTask(Model model) throws IllegalValueException {

        UniqueTagList tagList = getTagList(tagNames);

        if (startDate == null && endDate != null) {
            return new Deadline(id, name, description, endDate, tagList);
        }

        if (startDate != null && endDate != null) {
            return new Event(id, name, description, startDate, endDate, tagList);
        }

        return new Task(id, name, description, tagList);
    }

    private String getAddCommandSuccessMessage(List<Task> tasks) {

        StringBuilder sb = new StringBuilder();
        sb.append(String.format(MESSAGE_SUCCESS, taskList.get(0)));

        if (tasks.size() > 1) {
            sb.append("Task repeats " + recurringFrequency);
        }

        for (Task task : tasks) {

            if (!(task instanceof Event)) {
                continue;
            }

            Event event = (Event) task;
            Optional<Event> conflict = DateUtil.checkForConflictingEvents(model, event);

            if (conflict.isPresent()) {
                sb.append("\n");
                sb.append(Messages.CONFLICTING_EVENTS_DETECTED + " The event is:" + conflict.get().getName());
                break;
            }
        }

        return sb.toString();
    }

    private UniqueTagList getTagList(Iterable<String> tagNames) throws IllegalValueException {
        Set<Tag> tagSet = Sets.newHashSet();

        for (String name : tagNames) {
            tagSet.add(model.getTagRegistry().getTagFromString(name, true));
        }

        return new UniqueTagList(tagSet);
    }

    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>>(ImmutableList.copyOf(taskList),
                Collections.emptyList());
    }

```
###### \java\seedu\address\logic\commands\BlockCommand.java
``` java
/**
 * Allows users to "reserve" multiple timeslots for an unconfirmed event
 *
 */
public class BlockCommand extends Command {

    public static final String[] COMMAND_WORD = { "block", "reserve" };

    public static final String DEFAULT_COMMAND_WORD = COMMAND_WORD[0];
    public static final String MESSAGE_SUCCESS = "The following timeslots are reserved for %1$s: %2$s";

    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the ToDo list!";
    public static final String INVALID_TASK_TYPE_MESSAGE = "Please make sure you follow the correct block format.";
    public static final String DATES_NOT_DISTINCT_MESSAGE = "Please make sure there are no overlapping starting and ending dates.";
    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": Reserves timeslots for an event that is unconfirmed. \n"
            + "Every start date must have a corresponding end date \n"
            + "Format: Block EVENT_NAME st/START TIME et/END TIME [st/START TIME et/END_TIME]... \n"
            + "Example: block meeting with boss st/today 2pm et/today 4pm st/tommorrow 2pm et/tommorrow 4pm";

    private final String name;
    private final List<LocalDateTime> startDates;
    private final List<LocalDateTime> endDates;

    private List<Block> blocksToAdd;

    public BlockCommand(String name, List<LocalDateTime> startDates, List<LocalDateTime> endDates)
            throws IllegalValueException {

        if (startDates == null || endDates == null) {
            throw new IllegalValueException(INVALID_TASK_TYPE_MESSAGE);
        }

        if (!CollectionUtil.elementsAreUnique(startDates) || !CollectionUtil.elementsAreUnique(endDates)) {
            throw new IllegalValueException(DATES_NOT_DISTINCT_MESSAGE);
        }

        this.name = name;
        this.endDates = endDates;
        this.startDates = startDates;
    }

    @Override
    public CommandResult execute() {

        assert endDates.size() == startDates.size();
        assert model != null;

        int id = model.getNextTaskId();

        blocksToAdd = createBlocks(id) ;

        Transaction transaction = new Transaction(blocksToAdd);

        StringBuilder sb = new StringBuilder();

        while (transaction.hasNext()) {
            try {
                Block addedTask = transaction.addNext(model);

                sb.append(DateUtil.parseLocalDateTimeIntoString(addedTask.getStartDate()) + " to "
                        + DateUtil.parseLocalDateTimeIntoString(addedTask.getEndDate()));

                sb.append(" and ");

            } catch (DuplicateTaskException e) {

                transaction.rollback(model);
                return new CommandResult(MESSAGE_DUPLICATE_TASK);
            }
        }

        // Remove the last " and "
        sb.delete(sb.length() - 5, sb.length());

        return new CommandResult(String.format(MESSAGE_SUCCESS, name, sb.toString()), true);
    }
    
    private List<Block> createBlocks(int id) {
        List<Block> blocks = Lists.newArrayList() ;
        
        for (int i = 0; i < endDates.size(); i++) {
            blocks.add(i, new Block(id, name, startDates.get(i), endDates.get(i)));
        }
        
        return blocks ;
    }

    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>>(ImmutableList.copyOf(blocksToAdd),
                Collections.emptyList());
    }

    private static class Transaction {

        private List<Block> taskToAdd;
        private int index;

        public Transaction(List<Block> tasks) {
            this.taskToAdd = tasks;
            this.index = 0;
        }

        public Block addNext(Model model) throws DuplicateTaskException {

            Block task = taskToAdd.get(index);

            model.addTask(task);
            index++;

            return task;
        }

        public boolean hasNext() {
            return index < taskToAdd.size();
        }

        public void rollback(Model model) {

            if (index == 0) {
                return;
            }

            for (int i = index - 1; i >= 0; i--) {
                try {
                    model.deleteTask(taskToAdd.get(i));
                } catch (TaskNotFoundException e) {
                    continue;
                }
            }
        }
    }
}
```
###### \java\seedu\address\logic\commands\ConfigCommand.java
``` java
/**
 * Allows users to modify existing configuration values without modifying
 * config.json
 *
 */
public class ConfigCommand extends Command {

    public static final String COMMAND_WORD = "config";

    public static final String INVALID_CONFIG = "The given config option is not valid!";
    public static final String INVALID_CONFIG_VALUE = "The given config option and or value is not valid!";

    public static final String MESSAGE_IOEXCEPTION = "Something went wrong when saving the config file! Your file might be corrupted."
            + "Please try to delete it and load the app up again for the default config file!";
    public static final String MESSAGE_SUCCESS = "The following configuration option: %1$s is successfully set to %2$s";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the given config option to the given value \n"
            + "Format: config CONFIG_OPTION v/NEW VALUE \n" + "Example: config activeHoursFrom v/1000";

    private static final String RESET_TO_DEFAULT = "default";

    private final String configOption;
    private final String value;
    private final Class<?> configValueType;

    public ConfigCommand(String configOption, String value) throws IllegalValueException {
        this.configOption = configOption;
        this.value = value;
        this.configValueType = Config.getConfigValueType(configOption);

        if (configValueType == null) {
            throw new IllegalValueException(INVALID_CONFIG);
        }
    }

    @Override
    public CommandResult execute() {

        Config config = model.getConfigs();
        Object newConfigValue = value;

        if (RESET_TO_DEFAULT.equalsIgnoreCase(value)) {
            final Object defaultValue = (config.getDefaultConfigs().get(configOption) != null)
                    ? config.getDefaultConfigs().get(configOption).getValue() : null;

            if (defaultValue == null) {
                return new CommandResult(INVALID_CONFIG);
            }

            newConfigValue = defaultValue.toString();
        }

        try {
            newConfigValue = castStringIntoValue(configValueType, newConfigValue);

            config.setConfigurationOption(configOption, newConfigValue);
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);

        } catch (ClassCastException e) {
            return new CommandResult(INVALID_CONFIG_VALUE);

        } catch (IOException e) {
            return new CommandResult(MESSAGE_IOEXCEPTION);
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, configOption, newConfigValue), true);
    }

    private Object castStringIntoValue(Class<?> clazz, Object value) {

        if (String.class.getName().equals(clazz.getName())) {
            return value.toString();
        }

        if (Boolean.class.getName().equals(clazz.getName())) {
            return ("true".equalsIgnoreCase(value.toString()) || "1".equals(value.toString())) ? Boolean.TRUE
                    : Boolean.FALSE;
        }

        if (Integer.class.getName().equals(clazz.getName())) {
            return Integer.parseInt(value.toString());
        }

        return null;
    }

}
```
###### \java\seedu\address\logic\commands\ConfirmCommand.java
``` java
/**
 *
 * A command to confirm a previously blocked out timeslot(s)
 *
 */
public class ConfirmCommand extends Command {

    public static final String COMMAND_WORD = "confirm";

    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the ToDo list!";
    public static final String MESSAGE_CONFIRM_SUCCESS = "The following event is successfully confirmed: %1$s";
    public static final String MESSAGE_DATES_NOT_NULL = "Please enter in a pair of valid start and end dates/times!";
    public static final String MESSAGE_ONLY_BLOCKS = "You can only confirm an unconfirmed event!";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Confirms a previously blocked timeslot into an event. \n"
            + "The start and end date provided is the confirmed dates. \n"
            + "Format: confirm INDEX st/START TIME et/END TIME [d/DESCRIPTION] [t/tag...] \n"
            + "Example: confirm meeting with boss st/today 2pm et/today 4pm";

    private final int targetIndex;
    private final String startDate;
    private final String endDate;
    private final String description;
    private final Set<String> taglist;
    private final List<ReadOnlyTask> deletedTask, addedTask;

    public ConfirmCommand(int targetIndex, String description, String startDate, String endDate, Set<String> tags)
            throws IllegalValueException {

        if (startDate == null || endDate == null) {
            throw new IllegalValueException(MESSAGE_DATES_NOT_NULL);
        }

        this.targetIndex = targetIndex;
        this.startDate = startDate;
        this.endDate = endDate;
        this.description = description;
        this.taglist = tags;

        this.deletedTask = new ArrayList<>();
        this.addedTask = new ArrayList<>();
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTask();

        if (lastShownList.size() < targetIndex || targetIndex < 1) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        final ReadOnlyTask blockToConfirm = lastShownList.get(targetIndex - 1);

        if (!(blockToConfirm instanceof Block)) {
            return new CommandResult(MESSAGE_ONLY_BLOCKS);
        }

        Optional<Pair<LocalDateTime, LocalDateTime>> datePair = DateUtil.determineStartAndEndDateTime(startDate,
                endDate);

        if (!datePair.isPresent()) {
            return new CommandResult(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        }

        findAndDeleteOtherBlocks((Block) blockToConfirm);

        try {

            final Task newEvent = constructNewTask(blockToConfirm, datePair.get().getKey(), datePair.get().getValue());

            Optional<Event> conflict = DateUtil.checkForConflictingEvents(model, (Event) newEvent);

            model.addTask(newEvent);
            addedTask.add(newEvent);

            String successMessage = String.format(MESSAGE_CONFIRM_SUCCESS, newEvent);

            if (conflict.isPresent()) {
                successMessage = successMessage.concat(
                        "\n" + Messages.CONFLICTING_EVENTS_DETECTED + "The event is: " + conflict.get().getName());
            }
            return new CommandResult(successMessage, true);

        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage());
        }
    }

    private Task constructNewTask(final ReadOnlyTask blockToConfirm, LocalDateTime startDateTime,
            LocalDateTime endDateTime) throws IllegalValueException {

        final int id = model.getNextTaskId();
        final Set<Tag> newTags = getTagList(model, taglist);
        final String name = blockToConfirm.getName();
        final Task newEvent = new Event(id, name, description, startDateTime, endDateTime, new UniqueTagList(newTags));

        return newEvent;
    }

    private Set<Tag> getTagList(Model model, Iterable<String> tagStrings) throws IllegalValueException {
        Set<Tag> newTags = Sets.newHashSet();

        for (String tagName : taglist) {
            newTags.add(model.getTagRegistry().getTagFromString(tagName, true));
        }

        return newTags;
    }

    private void findAndDeleteOtherBlocks(Block task) {
        List<ReadOnlyTask> list = findAllOtherBlocks(task);

        for (ReadOnlyTask taskToDelete : list) {
            try {
                model.deleteTask(taskToDelete);
                deletedTask.add(taskToDelete);

            } catch (TaskNotFoundException e) {

                continue;
            }
        }
    }

    private List<ReadOnlyTask> findAllOtherBlocks(Block task) {

        assert model != null;

        int taskId = task.getTaskId();

        Expression filterByID = new PredicateExpression(new TaskIdentifierNumberQualifier(taskId));
        model.searchTaskList(filterByID);

        return new ArrayList<>(model.getSearchedTaskList());
    }

    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>>(ImmutableList.copyOf(addedTask),
                ImmutableList.copyOf(deletedTask));
    }
}
```
###### \java\seedu\address\logic\commands\DeleteCommand.java
``` java

/**
 * 
 * Deletes a task identified using it's last displayed index from the taskForce
 * list.
 */
public class DeleteCommand extends Command {

    public static final String[] COMMAND_WORD = { "delete", "remove" };

    public static final String DEFAULT_COMMAND_WORD = COMMAND_WORD[0];

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task(s): %1$s ";
    public static final String MESSAGE_DELETE_TASK_NOT_FOUND = "Task(s) not found: %1$s ";
    public static final String MESSAGE_DELETE_TASK_IGNORED = "The following indexes are invalid and ignored: %1$s ";

    public final List<Integer> targetIndexes;

    private final List<ReadOnlyTask> deletedTasks;

    public DeleteCommand(Integer... targetIndex) {
        this.targetIndexes = Lists.newLinkedList();
        this.deletedTasks = Lists.newLinkedList();

        for (int index : targetIndex) {
            this.targetIndexes.add(index);
        }
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTask();

        List<ReadOnlyTask> tasksToDelete = Lists.newLinkedList();

        DeleteMessageBuilder messageBuilder = new DeleteMessageBuilder();

        populateTaskToDeleteList(lastShownList, tasksToDelete, messageBuilder) ;

        if (tasksToDelete.isEmpty()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        for (ReadOnlyTask task : tasksToDelete) {

            try {
                model.deleteTask(task);
                deletedTasks.add(task);

                messageBuilder.addDeletedTaskDetails(task.getName());
            } catch (TaskNotFoundException pnfe) {
                messageBuilder.addTaskNotFound(task.getName());
            }
        }

        return new CommandResult(messageBuilder.getDeleteCommandResultString(), true);
    }
    
    private void populateTaskToDeleteList(List<ReadOnlyTask> lastShownList, List<ReadOnlyTask> tasksToDelete, 
            DeleteMessageBuilder builder) {
        
        for (int targetIndex : targetIndexes) {
            if (lastShownList.size() < targetIndex) {
                builder.addIgnoredIndex(targetIndex);
            } else {
                tasksToDelete.add(lastShownList.get(targetIndex - 1));
            }
        }
    }

    /**
     * 
     * A specialized class to build the success/failure message for the delete
     * command
     *
     */
    public static class DeleteMessageBuilder {

        private StringBuilder deletedTask;
        private StringBuilder ignoredIndexes;
        private StringBuilder tasksNotFound;

        public DeleteMessageBuilder() {
            this.deletedTask = new StringBuilder();
            this.ignoredIndexes = new StringBuilder();
            this.tasksNotFound = new StringBuilder();
        }

        public void addDeletedTaskDetails(String taskName) {
            deletedTask.append(taskName + " and ");
        }

        public void addIgnoredIndex(int index) {
            ignoredIndexes.append(index);
        }

        public void addTaskNotFound(String taskName) {
            tasksNotFound.append(taskName + " and ");
        }

        public String getDeletedTasks() {
            String result = deletedTask.toString();

            if (result.length() > 0) {
                return result.substring(0, result.length() - 5);
            }

            return "";
        }

        public String getIgnoredIndexes() {
            return ignoredIndexes.toString();
        }

        public String getTasksNotFound() {
            String result = tasksNotFound.toString();

            if (result.length() > 0) {
                return result.substring(0, result.length() - 5);
            }

            return "";
        }

        public String getDeleteCommandResultString() {
            StringBuilder sb = new StringBuilder();

            String taskNotFound = getTasksNotFound();
            String indexesIgnored = getIgnoredIndexes();
            String deletedTasks = getDeletedTasks();

            if (deletedTasks.length() > 0) {
                sb.append(String.format(MESSAGE_DELETE_TASK_SUCCESS, deletedTasks));
            }

            if (taskNotFound.length() > 0) {
                sb.append("\n");
                sb.append(String.format(MESSAGE_DELETE_TASK_NOT_FOUND, taskNotFound));
            }

            if (indexesIgnored.length() > 0) {
                sb.append("\n");
                sb.append(String.format(MESSAGE_DELETE_TASK_IGNORED, indexesIgnored));
            }

            return sb.toString();
        }
    }

    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>>(Collections.emptyList(),
                ImmutableList.copyOf(deletedTasks));
    }

}
```
###### \java\seedu\address\logic\filters\TaskIdentifierNumberQualifier.java
``` java
/**
 * 
 *          A simple qualifier to filter tasks via their task ID.
 *
 */
public class TaskIdentifierNumberQualifier implements Qualifier {

    private final int filterId;

    public TaskIdentifierNumberQualifier(int idToFilter) {
        this.filterId = idToFilter;
    }

    @Override
    public boolean run(ReadOnlyTask task) {

        return task != null && task.getTaskId() == filterId;
    }

}
```
###### \java\seedu\address\logic\parser\AddCommandParser.java
``` java
    private static <T> T getArgValueFromOptional(Optional<T> argValue, T defaultValue) {

        if (argValue.isPresent()) {
            return argValue.get();
        }

        return defaultValue;
    }

}
```
###### \java\seedu\address\logic\parser\ArgumentsParser.java
``` java
/**
 * 
 *          Given a command string with arguments, this class will extract the
 *          values from the string for easy retrieval
 * 
 */
public class ArgumentsParser {

    public static final int INVALID_VALUE_LENGTH = 0;

    private CommandArgs noFlagArgument;
    private Set<CommandArgs> requiredArguments;
    private Set<CommandArgs> optionalArguments;
    private Multimap<CommandArgs, String> argumentValuesMap;
    private Map<String, CommandArgs> flags;

    public ArgumentsParser() {
        this(false);

    }

    public ArgumentsParser(boolean maintainOrdering) {
        requiredArguments = Sets.newHashSet();
        optionalArguments = Sets.newHashSet();

        if (!maintainOrdering) {
            argumentValuesMap = ArrayListMultimap.create();

        } else {
            argumentValuesMap = LinkedListMultimap.create();

        }

        flags = Maps.newHashMap();

        this.addNoFlagArg(CommandArgs.NULL_ARG);
    }

    private void addFlag(CommandArgs arg) {
        for (String s : arg.getAliases()) {
            flags.put(s, arg);
        }
    }

    /**
     * Adds a no flag argument to this parser. A no flag argument is defined to
     * be an argument that appears at the very start of the command string. No
     * flag arguments are required and there can only be one no flag argument in
     * any command string
     * 
     * @param arg
     * @return
     */
    public ArgumentsParser addNoFlagArg(CommandArgs arg) {
        noFlagArgument = arg;
        addFlag(arg);

        return this;
    }

    /**
     * Adds a required argument.
     * <p>
     * 
     * A required argument is defined to be an argument that if not present in
     * the given command string, the command string will be deemed improper.
     * 
     * @param arg
     * @return this object for daisy chaining.
     */
    public ArgumentsParser addRequiredArg(CommandArgs arg) {
        requiredArguments.add(arg);
        addFlag(arg);

        return this;
    }

    /**
     * Adds a optional argument.
     * <p>
     * 
     * A optional argument is defined to be an argument that may or may not be
     * present in the given command string. The command string will be deemed
     * valid in both cases
     * 
     * @param arg
     * @return this object for daisy chaining.
     */
    public ArgumentsParser addOptionalArg(CommandArgs arg) {
        optionalArguments.add(arg);
        addFlag(arg);

        return this;
    }

    /**
     * Retrieves the associated values as a List of strings.
     * <p>
     * For example e/tag1 e/tag2 would return {tag1, tag2}. If there is only one
     * value, this will return a singleton list.
     * <p>
     * If there is no such flag present, return an {@code Optional.empty()}.
     * 
     * @param arg
     * @return
     */
    public Optional<List<String>> getArgValues(CommandArgs arg) {
        List<String> result = Lists.newLinkedList();

        if (!argumentValuesMap.containsKey(arg)) {
            return Optional.empty();
        }

        result.addAll(argumentValuesMap.get(arg));

        return Optional.of(result);
    }

    /**
     * Retrieves the associated values as a string.
     * <p>
     * Note if there is more than one value associated to this flag, only the
     * first arbitrary one will be returned.
     * <p>
     * If there is no such flag present, return an {@code Optional.empty()}.
     * 
     * @param arg
     * @return
     */
    public Optional<String> getArgValue(CommandArgs arg) {
        return getArgValues(arg).isPresent() ? Optional.of(getArgValues(arg).get().get(0)) : Optional.empty();
    }

    /**
     * Returns true if and only if the parsed command string contains a
     * flag-value pair containing at least one value
     * 
     * @param flag
     * @return
     */
    public boolean containsFlag(CommandArgs flag) {
        return argumentValuesMap.containsKey(flag);
    }

    /**
     * Parses the given commandString into their individual flag-value pairs.
     * 
     * @param commandString
     * @throws IncorrectCommandException
     *             if given command string does not match the required format
     */
    public void parse(String commandString) throws IncorrectCommandException {

        Deque<Character> charStack = Lists.newLinkedList();
        CommandArgs thisArg = noFlagArgument;

        String commandStringTrimmed = commandString.trim().concat(" $/"); // Append
                                                                          // a
                                                                          // unique
                                                                          // "end
                                                                          // of
                                                                          // string"
                                                                          // character

        for (int i = 0; i < commandStringTrimmed.length(); i++) {

            if (commandStringTrimmed.charAt(i) != '/') {
                charStack.push(commandStringTrimmed.charAt(i));
                continue;
            }

            if (thisArg == null) {
                throw new IncorrectCommandException();
            }

            CommandArgs nextArg = flags.get(extractFlagFromString(charStack));
            String value = extractArgValueFromString(charStack);

            if (thisArg != CommandArgs.NULL_ARG && value.length() == INVALID_VALUE_LENGTH) {
                throw new IncorrectCommandException();
            }

            argumentValuesMap.put(thisArg, value);
            thisArg = nextArg;

        }

        if (!isCommandStringValid()) {
            throw new IncorrectCommandException();
        }

    }

    private String extractFlagFromString(Deque<Character> stack) {

        StringBuilder sb = new StringBuilder();
        sb.append('/');

        while (stack.peekFirst() != null && stack.peekFirst() != ' ') {
            sb.append(stack.pop());
        }

        if (!stack.isEmpty()) {
            stack.pop();
        }

        return sb.reverse().toString();
    }

    private String extractArgValueFromString(Deque<Character> stack) {
        StringBuilder sb = new StringBuilder();

        while (stack.peekFirst() != null) {
            sb.append(stack.pop());
        }

        return sb.reverse().toString();
    }

    /**
     * A command string provided by the user is valid if and only if all
     * required arguments are present. Requires the command string to be
     * properly parsed first
     * 
     * @return true if command string provided by user is valid; false otherwise
     */
    private boolean isCommandStringValid() {

        Set<CommandArgs> argsPresent = argumentValuesMap.keySet();

        return argsPresent.containsAll(requiredArguments);
    }

}
```
###### \java\seedu\address\logic\parser\BlockCommandParser.java
``` java
public class BlockCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {

        ArgumentsParser parser = new ArgumentsParser(true);

        parser
        .addNoFlagArg(CommandArgs.NAME)
        .addRequiredArg(CommandArgs.END_DATETIME)
        .addRequiredArg(CommandArgs.START_DATETIME);

        try {
            parser.parse(args);


            List<LocalDateTime> startDateTimes = Lists.newLinkedList();
            List<LocalDateTime> endDateTimes = Lists.newLinkedList();
            convertArgsToDateTime(parser, startDateTimes, endDateTimes);
            
            return new BlockCommand(parser.getArgValue(CommandArgs.NAME).get(), startDateTimes, endDateTimes);
            
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());           
        } catch (IncorrectCommandException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE));
        }
    }

    private void convertArgsToDateTime(ArgumentsParser parser, List<LocalDateTime> startTimes,
            List<LocalDateTime> endTimes) throws IllegalValueException {

        assert parser != null;

        List<String> startStrings = parser.getArgValues(CommandArgs.START_DATETIME).orElse(Collections.emptyList());
        List<String> endStrings = parser.getArgValues(CommandArgs.END_DATETIME).orElse(Collections.emptyList());

        if (!startStrings.isEmpty() && !endStrings.isEmpty() && startStrings.size() == endStrings.size()) {

            for (int i = 0; i < startStrings.size(); i++) {
                Pair<LocalDateTime, LocalDateTime> startEndDates = DateUtil
                        .determineStartAndEndDateTime(startStrings.get(i), endStrings.get(i), false)
                        .orElseThrow(() -> new IllegalValueException(AddCommand.INVALID_END_DATE_MESSAGE));

                startTimes.add(startEndDates.getKey());
                endTimes.add(startEndDates.getValue());
            }

        } else {
            throw new IllegalValueException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE));
        }

    }
}
```
###### \java\seedu\address\logic\parser\ConfigCommandParser.java
``` java
/**
 * Command parser for the config command
 * 
 */
public class ConfigCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        ArgumentsParser parser = new ArgumentsParser();

        parser.addNoFlagArg(CommandArgs.NAME).addRequiredArg(CommandArgs.VALUES);

        try {
            parser.parse(args);
            
            return new ConfigCommand(parser.getArgValue(CommandArgs.NAME).get(),
                    parser.getArgValue(CommandArgs.VALUES).get());

        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        } catch (IncorrectCommandException e) {
            return new IncorrectCommand(
                    String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, ConfigCommand.MESSAGE_USAGE));
        }

    }

}
```
###### \java\seedu\address\logic\parser\ConfirmCommandParser.java
``` java
public class ConfirmCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        ArgumentsParser parser = buildArgsParser();

        try {
            parser.parse(args);

            if (!parser.getArgValue(CommandArgs.INDEX).isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
            }

            int targetIndex = getIndexFromArgs(parser);

            String startDate = parser.getArgValue(CommandArgs.START_DATETIME).get();
            String endDate = parser.getArgValue(CommandArgs.END_DATETIME).get();

            return new ConfirmCommand(targetIndex,
                    parser.getArgValue(CommandArgs.DESC).isPresent() ? parser.getArgValue(CommandArgs.DESC).get() : "",
                            startDate, endDate, parser.getArgValue(CommandArgs.TAGS).isPresent()
                            ? Sets.newHashSet(parser.getArgValue(CommandArgs.TAGS).get()) : Collections.emptySet());

        } catch (IncorrectCommandException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        }catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        }

    }

    private ArgumentsParser buildArgsParser() {
        ArgumentsParser parser = new ArgumentsParser();

        parser.addNoFlagArg(CommandArgs.INDEX).addRequiredArg(CommandArgs.START_DATETIME)
                .addRequiredArg(CommandArgs.END_DATETIME).addOptionalArg(CommandArgs.DESC)
                .addOptionalArg(CommandArgs.TAGS);

        return parser;
    }

    private int getIndexFromArgs(ArgumentsParser parser) throws IncorrectCommandException {
        String indexString = parser.getArgValue(CommandArgs.INDEX).get();

        if (!StringUtil.isParsable(indexString)) {
            throw new IncorrectCommandException();
        }

        return Integer.parseInt(indexString);
    }
}
```
###### \java\seedu\address\logic\parser\DeleteCommandParser.java
``` java
/* 
 * parsing arguments to and preparing them for delete command
 */
public class DeleteCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {

        String[] indexes = args.split(",");
        List<Integer> indexList = Lists.newLinkedList();

        for (String i : indexes) {
            Optional<Integer> index = parseIndex(i);

            if (!index.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }

            indexList.add(index.get());
        }

        Integer[] indexArray = new Integer[indexList.size()];

        return new DeleteCommand(indexList.toArray(indexArray));
    }
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * 
     *          Registers all associated command word strings with the provided
     *          command parser class. One command parser can be associated with
     *          multiple command words such as ("add", "schedule", etc)
     * 
     */
    public static void registerCommand(Class<? extends CommandParser> parser, String... command) {

        for (String word : command) {
            commandRegistry.put(word, parser);
        }
    }

    public static CommandParser getParserFromCommandWord(String commandWord) {

        if (!commandRegistry.containsKey(commandWord)) {
            return new IncorrectCommandParser();
        }

        Class<? extends CommandParser> parser = commandRegistry.get(commandWord);

        try {
            CommandParser commandParser = parser.newInstance();

            return commandParser;
        } catch (Exception e) {
            return new IncorrectCommandParser();
        }
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput
     *            full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());

        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        return getParserFromCommandWord(commandWord).prepareCommand(arguments);

    }

}
```
###### \java\seedu\address\model\tag\ReadOnlyTagRegistrar.java
``` java
/**
 *          A tag registry that disallows classes to reset the whole registry.
 */
public interface ReadOnlyTagRegistrar {

    public static final String MESSAGE_DUPLICATE_NAME = "The given tag name already exists!";

    /**
     * Given a tag string to the registry, the registry will return the Tag
     * object with tag name matching the given string.
     * <p>
     * Additionally if register is set to true, if the tag is not currently in
     * the registry, this create a new Tag object with the given string and
     * returns it. <br>
     * 
     * If not, this function returns null ;
     * 
     * @param tagString
     *            The tag name to be queried
     * @param register
     *            If true, this will register a new tag with the given name if
     *            not found; otherwise this will return null;
     * @return A tag object with the given tag name
     * @throws IllegalValueException
     *             if the given tag string is illegal and/or invalid
     */
    public Tag getTagFromString(String tagString, boolean register) throws IllegalValueException;

    /**
     * Given an existing tag, change its name to the given string
     * 
     * @param tag
     *            The tag object whose name is to be modified
     * @param newName
     *            the name to change into
     * 
     * @throws IllegalValueException
     *             if the given name is invalid and/or already exists.
     */
    public void changeTagName(Tag tag, String newName) throws IllegalValueException;

}
```
###### \java\seedu\address\model\tag\TagRegistrar.java
``` java
/**
 * 
 *          <p>
 * 
 *          Provides a central class to handle tag creation to prevent duplicate
 *          tags with similar names
 *
 */
public class TagRegistrar implements ReadOnlyTagRegistrar {

    private final Map<String, Tag> tagRegistry = Maps.newHashMap();

    @Override
    public Tag getTagFromString(String tagString, boolean register) throws IllegalValueException {

        String key = parseInput(tagString);

        if (tagRegistry.containsKey(key)) {
            return tagRegistry.get(key);
        }

        return (register) ? registerNewTag(key) : null;
    }

    private Tag registerNewTag(String tagString) throws IllegalValueException {
        String newTagString = parseInput(tagString);
        Tag newTag = new Tag(newTagString);

        tagRegistry.put(newTagString, newTag);

        return newTag;
    }

    private String parseInput(String input) {
        return (input != null) ? input.trim().toLowerCase() : null;
    }

    /**
     * Resets the registry and re-populate it with the given tags
     * 
     * @param tagIterable
     */
    public void setAllTags(Iterable<Tag> tagIterable) {
        tagRegistry.clear();

        for (Tag tag : tagIterable) {
            tagRegistry.put(parseInput(tag.tagName), tag);
        }
    }

    public void changeTagName(Tag tag, String newName) throws IllegalValueException {
        String name = parseInput(newName);
        String curName = tag.tagName;

        if (tagRegistry.containsKey(name)) {
            throw new IllegalValueException(MESSAGE_DUPLICATE_NAME);
        }

        tag.setTagName(name);

        tagRegistry.remove(curName);
        tagRegistry.put(name, tag);
    }
}
```
###### \java\seedu\address\model\task\Block.java
``` java
/**
 * 
 *          A block is a special event that is unconfirmed.
 *
 */
public class Block extends Event {

    public Block(int taskId, String name, LocalDateTime startDate, LocalDateTime endDate) {
        super(taskId, name, "", startDate, endDate, new UniqueTagList());
    }

}
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
    /**
     * 
     *          Converts this jaxb-friendly adapted task object into the model's
     *          Task object.
     *
     * @throws IllegalValueException
     *             if there were any data constraints violated in the adapted
     *             task
     */
    public Task toModelType() throws IllegalValueException {

        Task task;
        LocalDateTime start = null;
        LocalDateTime end = null;

        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }

        final String name = this.name;
        final String description = this.description;
        final boolean doneStatus = this.doneStatus;
        final boolean isBlock = this.isBlock;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        final int id = this.taskId;

        if (this.startDateTime != null) {
            start = LocalDateTime.parse(this.startDateTime);
        }

        if (this.endDateTime != null) {
            end = LocalDateTime.parse(this.endDateTime);
        }

        if (isBlock) {
            task = new Block(id, name, start, end);

        } else if (start != null && end != null) {
            task = new Event(id, name, description, start, end, tags, doneStatus);

        } else if (start == null && end != null) {
            task = new Deadline(id, name, description, end, tags, doneStatus);

        } else {
            task = new Task(id, name, description, tags, doneStatus);
        }

        return task;
    }
}
```
###### \java\seedu\address\ui\FreeTimeLine.java
``` java
/**
 * The main controller for the freetime command result visuals
 *
 */
public class FreeTimeLine extends UiPart {

    public static final int MAX_TIME_BLOCKS = 48;

    private static final String FXML = "FreetimeBar.fxml";
    
    private static final int RECT_WIDTH = 15 ;
    private static final int RECT_HEIGHT = 25 ;
    private static final int STARTING_POS = 5 ;

    private AnchorPane timelinepane;
    private AnchorPane placeHolderPane;

    private List<Rectangle> rectangles = Lists.newLinkedList();

    @FXML
    private AnchorPane timeline;

    public static FreeTimeLine load(Stage primaryStage, AnchorPane commandBoxPlaceholder) {
        FreeTimeLine freeTime = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new FreeTimeLine());
        freeTime.configure();
        freeTime.addToPlaceholder();
        return freeTime;
    }

    public void configure() {
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(timeline);
        FxViewUtil.applyAnchorBoundaryParameters(timelinepane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(timeline, 200.0, 0.0, 40.0, 0.0);

        timeline.setVisible(false);
    }

    @Override
    public void setNode(Node node) {
        timelinepane = (AnchorPane) node;

    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    private void drawTimeline(Map<Pair<Integer, Integer>, TimeStatus> timeStatuses) {

        TreeMap<Pair<Integer, Integer>, TimeStatus> sortedMap = sortTimeStatuses(timeStatuses);
        removeAllPreviousRects(timeline, rectangles);

        Entry<Pair<Integer, Integer>, TimeStatus> thisEntry = sortedMap.pollFirstEntry();

        int blockNo = 0;

        while (blockNo < MAX_TIME_BLOCKS) {

            while (thisEntry != null && blockNo >= thisEntry.getKey().getValue()) {
                thisEntry = sortedMap.pollFirstEntry();
            }

            Rectangle rect = createNewRect(blockNo);

            timeline.getChildren().add(rect);
            rectangles.add(rect);

            Color finalColor = null;

            if (thisEntry != null && blockNo >= thisEntry.getKey().getKey()
                    && blockNo < thisEntry.getKey().getValue()) {
                finalColor = determineRectColour(thisEntry.getValue());

            } else {
                finalColor = determineRectColour(null);
            }

            FillTransition ft = new FillTransition(Duration.millis(100 + (blockNo * 100)), rect, Color.TRANSPARENT,
                    finalColor);

            ft.play();

            blockNo++;

        }
    }

    private static void removeAllPreviousRects(AnchorPane parent, Collection<Rectangle> listOfRect) {
        parent.getChildren().removeAll(listOfRect);
        listOfRect.clear();
    }

    private static Rectangle createNewRect(int i) {

        Rectangle rect = new Rectangle(RECT_WIDTH, RECT_HEIGHT);

        rect.setLayoutX(STARTING_POS + (RECT_WIDTH * i));
        rect.setLayoutY(0);
        rect.setStroke(Paint.valueOf("black"));
        rect.setStrokeWidth(1F);
        rect.setOpacity(1);

        return rect;
    }

    private static TreeMap<Pair<Integer, Integer>, TimeStatus> sortTimeStatuses(
            Map<Pair<Integer, Integer>, TimeStatus> statusMap) {

        TreeMap<Pair<Integer, Integer>, TimeStatus> treeMap = new TreeMap<>(new Comparator<Pair<Integer, Integer>>() {

            @Override
            public int compare(Pair<Integer, Integer> arg0, Pair<Integer, Integer> arg1) {
                if (arg0.getKey() < arg1.getKey()) {
                    return -1;
                }

                if (arg0.getKey() > arg1.getKey()) {
                    return 1;
                }

                return 0;
            }

        });

        treeMap.putAll(statusMap);

        return treeMap;

    }

    private static Color determineRectColour(TimeStatus status) {
        if (status == TimeStatus.FREE) {
            return Color.web("#1aa260");
        }

        if (status == TimeStatus.NOT_FREE) {
            return Color.web("#de5347");
        }

        return Color.web("#7f7f7f");

    }

    @Subscribe
    private void onCommandExecutedEvent(TaskForceCommandExecutedEvent event) {
        if (event.commandInstance.getClass().equals(FreetimeCommand.class) && event.result.isSuccessfulCommand()) {

            FreetimeCommand command = (FreetimeCommand) event.commandInstance;

            timeline.setVisible(true);

            drawTimeline(command.getFreeTimeLine());

        } else {
            timeline.setVisible(false);
        }

    }

}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    private void loadCustomTrueTypeFonts() {
        // Loads the Open sans custom truetype font
        Font.loadFont(this.getClass().getResourceAsStream("/images/OpenSans-Light.ttf"), 12);
        Font.loadFont(this.getClass().getResourceAsStream("/images/OpenSans-Semibold.ttf"), 12);
    }

```
###### \java\seedu\address\ui\NodeStyle.java
``` java
/**
 * 
 * A simple Enum to encapsulate information about CSS classes
 * and the priority to which classes should be applied over another class
 * of the same type/family
 * 
 */
public enum NodeStyle {
    
    CIRCLE_HIGH ("CIRCLE", "circle_high", 0) ,
    CIRCLE_MED ("CIRCLE", "circle_deadline", Integer.MAX_VALUE) ,
    CIRCLE_REMINDER ("CIRCLE", "circle_reminder", 0) ,
    CIRCLE_DONE ("CIRCLE", "circle_done", -1) ,
    CIRCLE_BLOCK ("CIRCLE", "circle_block", -1) ,
    
    TITLE_NORMAL ("TITLE", "cell_big_label", Integer.MAX_VALUE) ,
    TITLE_OVERDUE ("TITLE", "cell_big_label_overdue", -2) ,
    TITLE_BLOCK ("TITLE", "cell_big_label_block", -1) ,
    TITLE_DONE ("TITLE", "cell_big_label_done", Integer.MIN_VALUE),
    
    TIME_NORMAL ("TIME", "cell_small_label", Integer.MAX_VALUE) ,
    TIME_BLOCK ("TIME", "time_block", -1) ,
    TIME_UPCOMING ("TIME", "time_upcoming", -1),
    TIME_OVERDUE ("TIME", "time_overdue", -2),
    TIME_DONE ("TIME", "time_done", Integer.MIN_VALUE)
    
    ;
    
    
    public final String family ;
    public final String className ;
    /** lower priority number = more important */
    public final int priority ; 
    
    private NodeStyle (String family, String className, int priority) {
        this.family = family ;
        this.className = className ;
        this.priority = priority ;
    }
    
    /**
     * Returns true if the given NodeStyle should overwrite this NodeStyle
     */
    public boolean shouldOverwriteStyle(NodeStyle other) {
        return other != null 
                && this.family.equals(other.family)
                && this.priority >= other.priority ;
    }

}
```
###### \java\seedu\address\ui\ResultDisplay.java
``` java
    public void commandExecuted(boolean success) {
        String addedClass;

        if (!success) {
            addedClass = "badCommand";
        } else {
            addedClass = "validCommand";
        }

        resultDisplayArea.getStyleClass().add(addedClass);

        Timeline reduceBorder = new Timeline(new KeyFrame(Duration.millis(2500), runnable -> reduceBorderWidth()));

        Timeline backToNormal = new Timeline(
                new KeyFrame(Duration.millis(5000), runnable -> changeBorderBack(addedClass)));

        reduceBorder.play();
        backToNormal.play();
    }

    private void changeBorderBack(String classToRemove) {
        resultDisplayArea.getStyleClass().remove(classToRemove);
    }

    private void reduceBorderWidth() {
        resultDisplayArea.setStyle("-fx-border-width: 2px ;");
    }

}
```
###### \java\seedu\address\ui\TaskCard.java
``` java
/**
 * The individual card element in GUI to display details of each task
 *
 */
public class TaskCard extends UiPart {

    private static final String FXML = "TaskListCard.fxml";
    
    private static final String DUE_ON = "Due on " ;
    private static final String DUE_IN = "Due in " ;

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("d MMM h:mm a");

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label description;
    @FXML
    private Label tags;
    @FXML
    private Circle circle;
    @FXML
    private Label startline;

    @FXML
    private Rectangle descBar;
    @FXML
    private ImageView clock;
    @FXML
    private ImageView isDone;

    private ReadOnlyTask task;
    private int displayedIndex;

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }
    
    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @FXML
    public void initialize() {
        setDefaultStyle();

        if (task.getDoneStatus()) {
            setTaskCardToDone();
        }

        setTaskTitle();
        displayTaskId();
        setDescriptionText();
        displayTagString();
        displayStartAndEndDates();
    }

    public HBox getLayout() {
        return cardPane;
    }

    private void setTaskCardToDone() {
        isDone.setVisible(true);
        FxViewUtil.setNodeStyle(name, NodeStyle.TITLE_DONE);
        FxViewUtil.setNodeStyle(circle, NodeStyle.CIRCLE_DONE);
        FxViewUtil.setNodeStyle(startline, NodeStyle.TIME_DONE);
    }

    private void displayTaskId() {
        id.setText(displayedIndex + ".");
    }

    private void setDefaultStyle() {
        startline.setVisible(false);
        clock.setVisible(false);
        isDone.setVisible(false);

        changeColourOfIndexCircle() ;
    }
    
    private void changeColourOfIndexCircle() {
        if (task instanceof Deadline || task instanceof Event) {
            FxViewUtil.setNodeStyle(circle, NodeStyle.CIRCLE_MED);
        } else {
            FxViewUtil.setNodeStyle(circle, NodeStyle.CIRCLE_REMINDER);
        }
    }

    private void setTaskTitle() {
        name.setText(task.getName());

        if (task instanceof Deadline && ((Deadline) task).isDeadlineOverdue()) {
            FxViewUtil.setNodeStyle(name, NodeStyle.TITLE_OVERDUE);
            FxViewUtil.setNodeStyle(circle, NodeStyle.CIRCLE_HIGH);
            FxViewUtil.setNodeStyle(startline, NodeStyle.TIME_OVERDUE);
        }

        if (task instanceof Block) {
            FxViewUtil.setNodeStyle(name, NodeStyle.TITLE_BLOCK);
            FxViewUtil.setNodeStyle(circle, NodeStyle.CIRCLE_BLOCK);
            FxViewUtil.setNodeStyle(startline, NodeStyle.TIME_BLOCK);
        }
    }

    private void setDescriptionText() {
        description.setText(task.getDescription());

        if (task.getDescription().length() == 0) {
            descBar.setVisible(false);
        }
    }

    private void displayStartAndEndDates() {
        if (task instanceof Deadline) {
            clock.setVisible(true);
            startline.setVisible(true);

            LocalDateTime deadline = ((Deadline) task).getEndDate();
            
            
            long difference = DateUtil.getTimeDifferenceFromNow(deadline, ChronoUnit.SECONDS);

            if (Math.abs(difference) > 5 * 3600) {
                // If task is more than 5 hours from now, display the absolute
                // dates
                startline.setText(DUE_ON + deadline.format(FORMATTER).toString());

            } else {
                FxViewUtil.setNodeStyle(startline, (difference > 0) ? NodeStyle.TIME_UPCOMING : null);
                startline.setText(DUE_IN + DateUtil.getRelativeDateFromNow(deadline));
            }
        }

        if (task instanceof Event) {
            startline.setVisible(true);
            clock.setVisible(true);

            String dateTimeText = formatEventDateString(((Event) task).getStartDate(), ((Event) task).getEndDate());
            startline.setText(dateTimeText);

        }
    }

    private void displayTagString() {
        String tagString = task.tagsString();

        tags.setText(tagString);

        if (tagString.length() == 0) {
            tags.setVisible(false);
        }
    }

    private String formatEventDateString(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        StringBuilder buffer = new StringBuilder();

        buffer.append(startDateTime.format(FORMATTER));
        buffer.append(" to ");
        buffer.append(endDateTime.format(FORMATTER));

        return buffer.toString();
    }

}
```
###### \resources\view\Extensions.css
``` css

.command-box {
	-fx-background-insets: 0;
	-fx-border-insets: 0;
    -fx-background-color: transparent, #f46060, transparent, #f46060;
    -fx-border-width: 1px ;
    -fx-border-color: #f46060 #f46060 #ffffff #f46060;
}

.result-display {
	-fx-font-family: "Open Sans Light" ;
	-fx-font-size: 14pt;
	-fx-text-fill: #7f7f7f ;
	-fx-background-insets: 0;
    -fx-background-color: transparent, #ececec, transparent, #ececec;
}

.badCommand {
	-fx-border-width: 3px ;
    -fx-border-color: #de5347 ;
    -fx-text-fill: #de5347 ;
}

.validCommand {
	-fx-border-width: 3px ;
    -fx-border-color: #1aa260 ;
    -fx-text-fill: #1aa260 ;
}

.error {
    -fx-background-color: #b50000;
}


.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}

.tooltip-text {
    -fx-text-fill: white;
}

/*
 * ====================================================================
 * ======================STYLES FOR CIRCLES============================
 * ====================================================================
 */

.circle_reminder {
	-fx-fill: derive(#4b8bf5, 0%);
}

.circle_deadline {
	-fx-fill: derive(#ffce43, 0%);
}
.circle_high {
	-fx-fill: derive(#de5347, 0%);
}

.circle_done {
	-fx-fill: derive(#1aa260, 0%);
}

.circle_block {
	-fx-fill: none ;
}

/*
 * ====================================================================
 * ======================STYLES FOR TITLES=============================
 * ====================================================================
 */
 
.cell_big_label_done .text {
	-fx-font-family: "Open Sans Light";
	-fx-strikethrough: true ;
	-fx-font-size: 16px;
    -fx-text-fill: #010504 ;
}

.cell_big_label_overdue {
	-fx-font-family: "Open Sans Semibold";
    -fx-font-size: 16px;
    -fx-font-weight: bold ;
    -fx-text-fill: #f46060 !important ;
}

.cell_big_label_block {
	-fx-font-family: "Open Sans Light";
    -fx-font-size: 16px;
    -fx-text-fill: #4f4f4e !important ;
}

/*
 * ====================================================================
 * ======================STYLES FOR DATES==============================
 * ====================================================================
 */

.time_block {
	-fx-text-fill: #4f4f4e !important ;
	-fx-font-size: 10pt;
}

.time_upcoming {
	-fx-text-fill: #4b8bf5 !important ;
	-fx-font-family: "Open Sans Semibold";
	-fx-font-size: 10pt;
}

.time_overdue {
	-fx-text-fill: #f46060 !important ;
	-fx-font-size: 10pt;
}


.time_done {
	-fx-text-fill: #010504 !important ;
	-fx-font-size: 10pt;
}

/*
 * Hides horizontal scrolling in list views
 */

.list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button {
    -fx-padding:0;
}

/* Empty cells will not have alternating colours */
.list-cell:empty {
    -fx-background: #ececec ;
}
```
###### \resources\view\FreetimeBar.fxml
``` fxml
<AnchorPane fx:id="timeline" prefHeight="50.0" prefWidth="720.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.FreeTimeLine">
   <children>
      <Line endX="725.0" layoutY="35.0" startX="5.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" AnchorPane.leftAnchor="-1.0" />
      <Line endX="10.0" layoutX="30.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="60.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="90.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="120.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="150.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="180.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="210.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="240.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="270.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="300.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="330.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="360.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="390.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="420.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="450.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="480.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="510.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="540.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="570.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="600.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="630.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="660.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="690.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      <Line endX="10.0" layoutX="720.0" layoutY="30.0" rotate="90.0" strokeWidth="2.0" />
      
      <Label layoutX="0.0" layoutY="33.0" text="12am" />
      <Label layoutX="90.0" layoutY="33.0" text="3am" />
      <Label layoutX="180.0" layoutY="33.0" text="6am" />
      <Label layoutX="270.0" layoutY="33.0" text="9am" />
      <Label layoutX="360.0" layoutY="33.0" text="12noon" />
      <Label layoutX="450.0" layoutY="33.0" text="3pm" />
      <Label layoutX="540.0" layoutY="33.0" text="6pm" />
      <Label layoutX="630.0" layoutY="33.0" text="9pm" />
      <Label layoutX="700.0" layoutY="33.0" text="11:59pm" />
      
   </children>
</AnchorPane>
```
###### \resources\view\Help.html
``` html

<h4 id="blocking-out-time-block">Blocking out time: <code>block | reserve</code></h4>
<p>Blocks out time for a potential event, or to indicate unavailability to others.<br />This command can block multiple timeslots at once, all for one specific event.<br />If multiple timeslots were blocked, when one timeslot is confirmed, all other timeslots are released (further explained in the <kbd>confirm</kbd> command)</p>
<p>Format: <code>block NAME st/START_DATE et/END_DATE [st/START_DATE et/END_DATE]...</code></p>
<blockquote>
<ul>
<li>Blocked out time is only blocked and cannot be tagged.<br /></li>
<li>Each st/ and et/ is a pair, and you can have unlimited pairs<br /></li>
<li>Date format is MM-DD-YYYY HHMM (24 hour Format) e.g. <code>st/ 10-22-2016 1500</code><br /></li>
<li>The command also supports natural language dates such as <code>today 6pm</code><br /></li>
<li>See the section <a href="#On%20Entering%20Dates">On Entering Dates</a> for more details<br /></li>
<li>If no start time is specified, the time will be assumed to be the time right now.<br /></li>
<li>If no start date is specified, it is assumed to be today.<br /></li>
<li>If no end date/time is specified, the end date/time will be the same day on 2359.<br /></li>
<li>You must have the <code>st/</code> &amp; <code>et/</code> tag even if you use default for both date and time</li>
</ul>
</blockquote>
<p>Examples:</p>
<ul>
<li><code>block meeting with boss st/1400 et/1600 st/tommorrow 1400 et/1600</code><br /></li>
<li><code>block study period st/1300 et/1800 st/tomorrow 2000 et/</code></li>
</ul>
<h4 id="confirming-previously-blocked-time-confirm">Confirming previously blocked time: <code>confirm</code></h4>
<p>Confirms a blocked out time and converts it into an event<br />Deletes all other blocked timeslots for the same event</p>
<p>Format: <code>confirm INDEX st/STARTTIME et/ENDTIME [d/DESCRIPTION][t/TAG]...</code></p>
<blockquote>
<ul>
<li>To use this function, you must first list the desired timelot, by either going to the right date to view it, or finding it through keywords<br /></li>
<li>Following which, you can use this command the confirm the desired slot you would like.<br /></li>
<li>All other times associated to the previously blocked out event will be released, even if they are not in the current view.</li>
</ul>
</blockquote>
<p>Examples:</p>
```
###### \resources\view\Help.html
``` html

<h4 id="deleting-a-task-delete">Deleting a task : <code>delete</code></h4>
<p>Deletes the specified task from the task list. Irreversible.<br />Format: <code>delete INDEX[, INDEX,...]</code></p>
<blockquote>
<ul>
<li>Delete the task at the specified <code>INDEX</code>.<br /></li>
<li>To delete more than one task, seperate the tasks indexes with commas.<br /></li>
<li>The index refers to the index number shown in the most recent listing.<br><br /></li>
<li>The index <strong>must be a positive integer</strong> 1, 2, 3, ...</li>
</ul>
</blockquote>
<p>Examples:</p>
<ul>
<li><code>find all/ Meeting</code><br><br /> <code>delete 1</code><br><br /> Deletes the 1st task in the results of the <code>find</code> command.</li>
</ul>
```
###### \resources\view\Help.html
``` html


<h4 id="changing-configuration-options-config">Changing configuration options : <code>config</code></h4>
<p>Allows for changing of configuration options in config.json <br><br /><strong>Warning: This is for advanced users only!</strong> <br><br />Format : <code>config CONFG_OPTION v/NEW_VALUE</code> <br><br />The following table are the config options and its values that is avaliable for modification by this command. <br></p>
<table>
<thead>
<tr class="header">
<th align="left">Configuration Option</th>
<th align="left">Values</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">taskForceDataFilePath</td>
<td align="left">Use the <code>cd</code> command</td>
<td align="left">The location of the data save file</td>
</tr>
<tr class="even">
<td align="left">userPrefsFilePath</td>
<td align="left">A file path</td>
<td align="left">The location of the user preferences file</td>
</tr>
<tr class="odd">
<td align="left">activeHoursFrom</td>
<td align="left">0000 to 2400</td>
<td align="left">The earliest hour that the freetime command would take into account when computing your freetime</td>
</tr>
<tr class="even">
<td align="left">activeHoursTo</td>
<td align="left">0000 to 2400</td>
<td align="left">The latest hour that the freetime command would take into account when computing your freetime</td>
</tr>
<tr class="odd">
<td align="left">enableSudo</td>
<td align="left">true or false</td>
<td align="left">When enabled, you can perform the clear command and other commands for advanced users</td>
</tr>
</tbody>
</table>
```
###### \resources\view\Help.html
``` html

<h2 id="date-format">Date Format</h2>
<p>TaskForce supports flexible date inputs and thus allows many natural variations of dates. The following are three broad categories of dates supported by TaskForce</p>
<h3 id="formal-dates">Formal Dates</h3>
<blockquote>
<p>Format Dates follow the format MM-DD-YYYY HHMM <br></p>
<ul>
<li>03-15-2016 1500</li>
</ul>
</blockquote>
<h3 id="relaxed-dates">Relaxed Dates</h3>
<blockquote>
<p>Relaxed dates are dates that expressed months in words instead of numbers. If the year is not provided, it is assumed to be this year</p>
<ul>
<li>Oct 20 2016<br /></li>
<li>16 Aug</li>
</ul>
</blockquote>
<h3 id="relative-dates">Relative dates</h3>
<blockquote>
<p>Relative dates are the most natural variation of the three and supports inputs that is relative to today <br></p>
<ul>
<li>today 5pm<br /></li>
<li>next thursday 3pm<br /></li>
<li>tomorrow 9am</li>
</ul>
</blockquote>

```
###### \resources\view\TaskListCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" maxHeight="93.0" maxWidth="575.0" minWidth="575.0" prefHeight="93.0" prefWidth="575.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1">
    <children>
      <AnchorPane prefHeight="88.0" prefWidth="105.0">
         <children>
            <Circle fx:id="circle" layoutX="52.0" layoutY="46.0" radius="23.0" stroke="BLACK" strokeType="INSIDE" styleClass="circle_low" AnchorPane.bottomAnchor="24.0" AnchorPane.leftAnchor="29.0" AnchorPane.rightAnchor="29.0" AnchorPane.topAnchor="23.0" />
            <Label fx:id="id" layoutX="46.0" layoutY="36.0" prefHeight="21.0" prefWidth="27.0" styleClass="task_id" text="Label" textAlignment="CENTER" AnchorPane.bottomAnchor="36.0" AnchorPane.leftAnchor="46.0" AnchorPane.rightAnchor="31.0" AnchorPane.topAnchor="36.0" />
         </children>
      </AnchorPane>
      <AnchorPane maxWidth="450.0" prefHeight="93.0" prefWidth="450.0">
         <children>
                     <Label fx:id="name" layoutX="2.0" layoutY="7.0" styleClass="cell_big_label" text="\$first" AnchorPane.leftAnchor="2.0" AnchorPane.topAnchor="7.0" />
            <AnchorPane layoutX="2.0" layoutY="27.0" maxWidth="470.0" prefHeight="64.0" prefWidth="409.0">
               <children>
                        <Label fx:id="description" layoutX="12.0" layoutY="1.0" prefHeight="21.0" prefWidth="452.0" styleClass="cell_small_label" text="\$description" AnchorPane.leftAnchor="12.0" AnchorPane.topAnchor="1.0" />
                  <Rectangle fx:id="descBar" arcHeight="5.0" arcWidth="5.0" fill="#f46060" height="20.0" layoutX="3.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0" width="5.0" AnchorPane.leftAnchor="3.0" AnchorPane.topAnchor="3.0" />
                  <ImageView fx:id="clock" fitHeight="20.0" fitWidth="20.0" layoutX="-1.0" layoutY="27.0" pickOnBounds="true" preserveRatio="true" AnchorPane.bottomAnchor="17.0" AnchorPane.leftAnchor="-1.0">
                     <image>
                        <Image url="@../images/clock.png" />
                     </image>
                  </ImageView>
                  <Label fx:id="startline" layoutX="22.0" layoutY="27.0" styleClass="cell_small_label" text="\$startline" AnchorPane.leftAnchor="22.0" AnchorPane.topAnchor="27.0" />
                  <ImageView fx:id="isDone" fitHeight="28.0" fitWidth="25.0" layoutX="425.0" layoutY="24.0" pickOnBounds="true" preserveRatio="true" AnchorPane.leftAnchor="425.0" AnchorPane.topAnchor="24.0">
                     <image>
                        <Image url="@../images/mark.png" />
                     </image>
                  </ImageView>
               </children></AnchorPane>
                    <Label fx:id="tags" layoutX="408.0" style="-fx-border-color: FFFF;" styleClass="cell_small_label" text="\$tags" AnchorPane.rightAnchor="20.0" AnchorPane.topAnchor="0.0" />
         </children>
      </AnchorPane>
    </children>
</HBox>
```
