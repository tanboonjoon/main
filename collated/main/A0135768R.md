# A0135768R
###### \java\seedu\address\commons\core\Config.java
``` java
 * Config values used by the app
 */
public class Config {

    public static final String DEFAULT_CONFIG_FILE = "config.json";
    
    @JsonIgnore
    private static final Map<String, Pair<Class<?>, Object>> DEFAULT_CONFIGS = Maps.newHashMap() ;

    // Config values customizable through config file
    private Map<String, Object> configRegistry = Maps.newHashMap() ;
    
    static {

       Config.<String>registerNewConfigWithDefault("appTitle", "Task Force") ;
       Config.<String>registerNewConfigWithDefault("userPrefsFilePath", "preferences.json") ;
       Config.<String>registerNewConfigWithDefault("taskForceDataFilePath", "data/taskForceData.xml") ;
       Config.<String>registerNewConfigWithDefault("appName", "My Todo list") ;
       Config.<String>registerNewConfigWithDefault("activeHoursFrom", "0800") ;
       Config.<String>registerNewConfigWithDefault("activeHoursTo", "2100") ;
       Config.<Boolean>registerNewConfigWithDefault("enableSudo", false) ;
       
    }
    
    private static <T> void registerNewConfigWithDefault (String key, T value) {
        DEFAULT_CONFIGS.put(key, new Pair<Class<?>, Object>(value.getClass(), value)) ;
    }
    
    public static Class<?> getConfigValueType (String configOption) {
        return (DEFAULT_CONFIGS.get(configOption) != null) ? DEFAULT_CONFIGS.get(configOption).getKey() : null ;
    }
    
    public Config () {
        resetAndregisterDefaultConfigs() ;
    }
    
    public void resetAndregisterDefaultConfigs() {
        configRegistry.clear() ;
        
        for (Entry<String, Pair<Class<?>, Object>> entry : DEFAULT_CONFIGS.entrySet()) {
            
            Class<?> clazz = entry.getValue().getKey() ;
            Object value = entry.getValue().getValue() ;
            
            configRegistry.put(entry.getKey(), clazz.cast(value)) ;
            
        }
    }
    
    public <T> void setConfigurationOption (String key, T value) {
        
        if (DEFAULT_CONFIGS.containsKey(key)) {
            configRegistry.put(key, value) ;
        
        } else {
            configRegistry.replace(key, value) ;
        }
    }
    
    public <T> T getConfigurationOption (String key) {
        if (!configRegistry.containsKey(key)) {
            return (T) DEFAULT_CONFIGS.get(key).getValue() ;
        }
        
        return (T) configRegistry.get(key) ;
    }
    
    public ImmutableMap<String, Pair<Class<?>, Object>> getDefaultConfigs() {
        return ImmutableMap.copyOf(DEFAULT_CONFIGS) ;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this){
            return true;
        }
        if (!(other instanceof Config)){ //this handles null as well.
            return false;
        }

        Config o = (Config)other;

        return configRegistry.equals(o.configRegistry) ;
    }

    @Override
    public int hashCode() {
        return configRegistry.hashCode() ;
    }

    @Override
    public String toString(){
        StringBuilder sb = new StringBuilder();
        
        for (Entry<String, Object> entry : configRegistry.entrySet()) {
            sb.append(entry.getKey() + ": " + entry.getValue()) ;
            sb.append("\n") ;
        }
        
        return sb.toString();
    }
    
    public static String getDefaultConfigString() {
        Config config = new Config () ;
        
        return config.toString() ;
    }
    
    // The getter and setters are left alone for minimal code impact
```
###### \java\seedu\address\commons\events\model\TaskForceCommandExecutedEvent.java
``` java
 * <p>
 * This event is fired right after a command is executed.
 * 
 */
public class TaskForceCommandExecutedEvent extends BaseEvent {
	
	public final Command commandInstance ;
	public final CommandResult result ;
	
	public TaskForceCommandExecutedEvent (Command commandInstance, CommandResult result) {
		this.commandInstance = commandInstance ;
		this.result = result ;
		
	}

	@Override
	public String toString() {
	    return "Command Executed: " + commandInstance.getClass().getSimpleName() + ". Command Success:" + result.isSuccessfulCommand() ;
	}

}
```
###### \java\seedu\address\commons\util\DateUtil.java
``` java
public final class DateUtil {


    public static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy hh:mm a");
    public static final LocalDateTime END_OF_TODAY = parseStringIntoDateTime("today 2359").get() ;
    public static final LocalDateTime NOW = LocalDateTime.now() ;
	public static final LocalDateTime MARKER_FOR_DELETE = LocalDateTime.MIN ;
	public static final String STRING_FOR_DELETE = "-"; 

    public static Optional<LocalDateTime> parseStringIntoDateTime (String rawString) {

        if (rawString == null) {
            return Optional.empty() ;
        }
        
	    if (rawString.equals(STRING_FOR_DELETE)) {	
	    	return Optional.of(MARKER_FOR_DELETE);
	    }
	    

        Parser dateParser = new Parser() ;

        List<DateGroup> dates = dateParser.parse(rawString) ;

        try {
            Date date = dates.get(0).getDates().get(0) ;

            return Optional.of(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault())) ;

        } catch (IndexOutOfBoundsException e) {
            return Optional.empty() ;
        }
    }

    public static String parseLocalDateTimeIntoString (LocalDateTime datetime) {
        assert datetime != null ;

        return datetime.format(FORMATTER) ;
    }

    /**
     * Given a new event that is being added/to be added to the model, checks that if any events currently in the model
     * that will conflict with the given event. If the given event is already added to the model, it will be ignored - that is
     * an event cannot conflict with itself.
     * 
     * @param model     The model of the TaskForce - cannot be null.
     * @param eventToBeAdded    The event that is being added/or already added to the model.
     * @return      {@link Optional.empty()} if there is no conflict; otherwise an arbitrary conflicting event is returned.
     */
    public static Optional<Event> checkForConflictingEvents (Model model, Event eventToBeAdded) {
        assert model != null ;

        LocalDateTime startTime = eventToBeAdded.getStartDate() ;
        LocalDateTime endTime = eventToBeAdded.getEndDate() ;

        assert startTime.isBefore(endTime) ;

        Long days = ChronoUnit.DAYS.between(startTime, endTime) ;

        model.searchTaskList(new PredicateExpression(new NameQualifier(Sets.newHashSet(days.toString()), NameQualifier.FILTER_BY_DAY, false)) );

        PriorityQueue<Event> pq = new PriorityQueue<>(new EventComparator()) ;

        for (ReadOnlyTask task : model.getSearchedTaskList()) {

            if ( !(task instanceof Event) || task.equals(eventToBeAdded) ) {
                continue ;
            }

            pq.add((Event) task) ;

        }

        // Don't need to do anything if there is no events occuring on this time period
        if (pq.isEmpty()) {
            return Optional.empty() ;
        }

        Event event = pq.poll() ;

        while (event != null && event.getEndDate().isAfter(startTime)) {

            if (event.getStartDate().isBefore(endTime)) {
                return Optional.of(event);
            }

            event = pq.poll() ;
        }

        return Optional.empty() ;

    }


    private static Optional<Pair<LocalDateTime, LocalDateTime>> determineStartAndEndDateTime(Optional<LocalDateTime> startDate, Optional<LocalDateTime> endDate, boolean canBeEmpty) {

        LocalDateTime computedStartDate ;
        LocalDateTime computedEndDate ;

        if (!startDate.isPresent() && !endDate.isPresent()) {
            return Optional.empty() ;
        }
        
        if (!canBeEmpty && (!startDate.isPresent() || !endDate.isPresent())) {
            return Optional.empty() ;
        }

        if (!startDate.isPresent() || !endDate.isPresent()) {
            computedStartDate = startDate.orElse(DateUtil.NOW) ;
            computedEndDate = endDate.orElse(computedStartDate.withHour(23).withMinute(59)) ;

            return Optional.of(new Pair<LocalDateTime, LocalDateTime> (computedStartDate, computedEndDate)) ;
        }

        if (endDate.get().isBefore(startDate.get()) && isDateComponentSameAsNow(endDate.get())) {
            computedStartDate = startDate.get() ;

            int seconds = endDate.get().getSecond() ;
            int minutes = endDate.get().getMinute() ;
            int hours = endDate.get().getHour() ;

            computedEndDate = startDate.get().withHour(hours).withMinute(minutes).withSecond(seconds) ;

            if (computedStartDate.isBefore(computedEndDate)) {
                return Optional.of(new Pair<LocalDateTime, LocalDateTime> (computedStartDate, computedEndDate)) ;
            }

        } else if (endDate.get().isAfter(startDate.get())) {

            return Optional.of(new Pair<LocalDateTime, LocalDateTime> (startDate.get(), endDate.get())) ;

        }

        return Optional.empty() ;

    }


    /**
     * Given one and start and end date, the function will return a corresponding start and end dates following these rules: <p>
     * 
     * - If both dates are empty, it will return Optional.empty <br>
     * - If only start date is empty, the start date shall assumed to be now.
     * <br>
     * - If only end date is empty, the end date shall be assumed to be on the same day of the start date at 2359
     * <br>
     * - If a start datetime is provided and only end time is provided, the end datetime is assumed to be on the same day as the start
     * date on the time provided.
     * <p>
     * If start datetime happens to be after end datetime, this function will return Optional.empty()
     * <p>
     * 
     * If the boolean allowEmptyValues is set to false, however, then if any dates is empty, this will return {@link Optional.empty()}
     * This is set to true by default if not specified
     * 
     * <p>
     * 
     * @param startString string that will be parsed by natty
     * @param endString string that will be parsed by natty
     * @return a LocalDateTime pair with the key being the starting datetime, and the value the ending datetime
     */
    public static Optional<Pair<LocalDateTime, LocalDateTime>> determineStartAndEndDateTime(String startString, String endString) {
        return determineStartAndEndDateTime(parseStringIntoDateTime(startString), parseStringIntoDateTime(endString), true) ;
    }
    
    public static Optional<Pair<LocalDateTime, LocalDateTime>> determineStartAndEndDateTime(String startString, String endString, boolean allowEmptyValues) {
        return determineStartAndEndDateTime(parseStringIntoDateTime(startString), parseStringIntoDateTime(endString), allowEmptyValues) ;
    }

    private static boolean isDateComponentSameAsNow (LocalDateTime dateTime) {
        LocalDate now = LocalDate.now() ;
        LocalDate givenDate = dateTime.toLocalDate() ;

        return now.equals(givenDate) ;
    }
    
    public static String getRelativeDateFromNow (LocalDateTime dateTime) {
        Long milis = ChronoUnit.MILLIS.between(NOW, dateTime) ;
        
        return RelativeTimeConverter.toDuration(milis) ;
    }
    
    public static long getTimeDifferenceFromNow (LocalDateTime dateTime, ChronoUnit units) {
        long diff = units.between(NOW, dateTime) ;
        
        return diff ;
    }

    // Comparator for priority queue
    private static class EventComparator implements Comparator<Event> {

        @Override
        public int compare(Event arg0, Event arg1) {
            LocalDateTime arg0Date = arg0.getEndDate() ;
            LocalDateTime arg1Date = arg1.getEndDate() ;

            if (arg0Date.isBefore(arg1Date)) {
                return 1 ;
            }

            if (arg0Date.isAfter(arg1Date)) {
                return -1 ;
            }

            return 0 ;
        }

    }

    private static class RelativeTimeConverter {
        
        public static final ImmutableList<Long> TIMES = ImmutableList.of(
                TimeUnit.DAYS.toMillis(365),
                TimeUnit.DAYS.toMillis(30),
                TimeUnit.DAYS.toMillis(1),
                TimeUnit.HOURS.toMillis(1),
                TimeUnit.MINUTES.toMillis(1),
                TimeUnit.SECONDS.toMillis(1) );
        
        public static final ImmutableList<String> TIME_STIRNGS = ImmutableList.of("year","month","day","hour","minute","second");

        
        public static String toDuration(long miliseconds) {
            
            long duration = Math.abs(miliseconds) ;

            StringBuffer sb = new StringBuffer();
            
            for(int i = 0; i < TIMES.size(); i ++) {
                Long current = TIMES.get(i);
                long temp = duration/current;
                
                if(temp>0) {
                    sb.append(temp) ;
                    sb.append(" ") ;
                    sb.append( TIME_STIRNGS.get(i) ) ;
                    sb.append(temp > 1 ? "s" : "") ;
                    
                    break;
                }
            }
            
            if( "".equals(sb.toString()) ) {
                return "0 second ago";
            } 
            
            if (miliseconds > 0) {
                sb.append(" later") ;
            
            } else {
                sb.append(" ago") ;
            }
            
            return sb.toString();
        }
    }
}
```
###### \java\seedu\address\commons\util\FxViewUtil.java
``` java
 * 
 * Contains utility methods for JavaFX views
 */
public class FxViewUtil {
    
    public static final ImmutableMap<String, NodeStyle> NODE_STYLES ;
    
    static {
        
        Builder <String, NodeStyle> builder = ImmutableMap.builder() ;
        
        for (NodeStyle nodeStyle : NodeStyle.values()) {
            builder.put(nodeStyle.className, nodeStyle) ;
        }
        
        NODE_STYLES = builder.build() ;
    }
        
    
    public static void removeAndAddCssClass (Node node, String classToRemove, String classToAdd) {
        node.getStyleClass().remove(classToRemove) ;
        node.getStyleClass().add(classToAdd) ;
    }
    
    /**
     * Sets the style of the given node with the given style CSS class if it satisfies the following rule : <p>
     * 
     * - The given style has a integer priority lower or equals to all other CSS classes of the same family
     * currently applied to this node
     * 
     * @param node      The node to apply the style to
     * @param style     A NodeStyle representing the CSS class that is to be applied onto the given node 
     */
    public static void setNodeStyle (Node node, NodeStyle style) {
        
        if (style == null) {
            return ;
        }
        
        String family = style.family ;
        
        List<String> classToRemove = new ArrayList<>() ;
        String classToAdd = style.className ;
        
        for (String CssClass : node.getStyleClass()) {
            NodeStyle nodeStyle = NODE_STYLES.get(CssClass) ;
            
            if (nodeStyle != null && nodeStyle.family.equals(family) && nodeStyle.priority >= style.priority) {
                classToRemove.add(nodeStyle.className) ;
            }
            
            if (nodeStyle != null && nodeStyle.family.equals(family) && nodeStyle.priority < style.priority) {
                classToAdd = null ;
            }
        }

        node.getStyleClass().removeAll(classToRemove) ;
        
        if (classToAdd != null) {
            node.getStyleClass().add(classToAdd) ;
        }
        
    }
    
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
     * 
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String description,String startDate,String endDate, Set<String> tags, String recurring, String repeat) throws IllegalValueException {

        setRecurrenceAttributes(recurring, repeat);

        if (startDate == null && endDate == null) {

            setNewTaskWithDetails(name, description, tags);

        } else if (startDate == null && endDate != null) {

            Optional<Pair<LocalDateTime, LocalDateTime>> datePair = DateUtil.determineStartAndEndDateTime(null, endDate) ;

            setNewTaskWithDetails(name, description, datePair.get().getValue(), tags);     	

        } else if (startDate !=null) {

            Optional<Pair<LocalDateTime, LocalDateTime>> datePair = DateUtil.determineStartAndEndDateTime(startDate, endDate) ;

            if (!datePair.isPresent()) {
                throw new IllegalValueException(INVALID_END_DATE_MESSAGE);
            }

            setNewTaskWithDetails (name, description, datePair.get().getKey(), datePair.get().getValue(), tags) ;
        } else {
            throw new IllegalValueException(INVALID_TASK_TYPE_MESSAGE);
        }
    }


    @Override
    public CommandResult execute() {
        assert model != null;
        this.id = model.getNextTaskId();

        if(recurringFrequency != null && repeat == 0) {
            return new CommandResult(MISSING_NUMBER_OF_RECURRENCE_MESSAGE) ;

        } 

        try {

            if (recurringFrequency != null && repeat >= MIN_NUMBER_OF_RECURRENCE){
                this.createRecurringEvent(model, recurringFrequency, repeat) ;
            
            } else {
                this.taskList.add(getNewTask(model)) ;
                
            }
            
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage());
        }

        try {

            for(Task task: taskList) {
                model.addTask(task);
            }

            return new CommandResult(getAddCommandSuccessMessage(taskList), true);

        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }

    private void setNewTaskWithDetails (String name, String description, LocalDateTime startDate, LocalDateTime endDate, Set<String> tags) {
        this.name = name ;
        this.description = description ;
        this.startDate = startDate ;
        this.endDate = endDate ;
        this.tagNames = tags ;
    }

    private void setNewTaskWithDetails (String name, String description, LocalDateTime endDate, Set<String> tags) {
        setNewTaskWithDetails(name, description, null, endDate, tags) ;
    }

    private void setNewTaskWithDetails (String name, String description, Set<String> tags) {
        setNewTaskWithDetails(name, description, null, null, tags) ;
    }

    private Task getNewTask (Model model) throws IllegalValueException {

        Set<Tag> tagSet = Sets.newHashSet() ;

        for (String name : tagNames) {
            tagSet.add(model.getTagRegistry().getTagFromString(name, true)) ;

        }

        UniqueTagList tagList = new UniqueTagList(tagSet) ;

        if (startDate == null && endDate != null) {
            return new Deadline (id, name, description, endDate, tagList) ;
        }

        if (startDate != null && endDate != null) {
            return new Event (id, name, description, startDate, endDate, tagList) ;
        }
        return new Task (id, name, description, tagList) ;
    }

    private String getAddCommandSuccessMessage (List<Task> tasks) {

        StringBuilder sb = new StringBuilder() ;
        sb.append(String.format(MESSAGE_SUCCESS, taskList.get(0))) ;

        if (tasks.size() > 1) {
            sb.append("Task repeats " + recurringFrequency) ;
        }

        for (Task task : tasks) {

            if ( !(task instanceof Event) ) {
                continue ;
            }

            Event event = (Event) task ;
            Optional<Event> conflict = DateUtil.checkForConflictingEvents(model, event) ;

            if (conflict.isPresent()) {
                sb.append("\n") ;
                sb.append(Messages.CONFLICTING_EVENTS_DETECTED + " The event is:" + conflict.get().getName()) ;
                break ;
            }
        }


        return sb.toString() ;
    }

    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>>(ImmutableList.copyOf(taskList), Collections.emptyList()) ;
    }

```
###### \java\seedu\address\logic\commands\BlockCommand.java
``` java
public class BlockCommand extends Command {
    
    public static final String[] COMMAND_WORD = {
            "block",
            "reserve"
    };
    
    public static final String DEFAULT_COMMAND_WORD = COMMAND_WORD[0] ;
    public static final String MESSAGE_SUCCESS = "The following timeslots are reserved for %1$s: %2$s";
    
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the ToDo list!";
    public static final String INVALID_TASK_TYPE_MESSAGE = "Please make sure you follow the correct block format.";
    public static final String DATES_NOT_DISTINCT_MESSAGE = "Please make sure there are no overlapping starting and ending dates." ;
    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD + ": Reserves timeslots for an event that is unconfirmed. \n" 
            + "Every start date must have a corresponding end date \n"
            + "Format: Block EVENT_NAME st/START TIME et/END TIME [st/START TIME et/END_TIME]... \n"
            + "Example: block meeting with boss st/today 2pm et/today 4pm st/tommorrow 2pm et/tommorrow 4pm" ;
    
    private final String name ;
    private final List<LocalDateTime> startDates ;
    private final List<LocalDateTime> endDates ;
    
    private List<Block> blocksToAdd ;
    
    
    public BlockCommand (String name, List<LocalDateTime> startDates, List<LocalDateTime> endDates) throws IllegalValueException {
        
        if (startDates == null || endDates == null) {
            throw new IllegalValueException(INVALID_TASK_TYPE_MESSAGE);
        }
        
        if (!CollectionUtil.elementsAreUnique(startDates) || !CollectionUtil.elementsAreUnique(endDates) ) {
            throw new IllegalValueException(DATES_NOT_DISTINCT_MESSAGE);
        }
        
        this.name = name ;
        this.endDates = endDates ;
        this.startDates = startDates ;     
    }
    
    @Override
    public CommandResult execute() {
        
        assert endDates.size() == startDates.size() ;
        assert model != null ;
        
        int id = model.getNextTaskId() ;
        
        blocksToAdd = new ArrayList<>(endDates.size()) ;
        
        for (int i = 0; i < endDates.size(); i ++) {
            blocksToAdd.add(i, new Block (id, name, startDates.get(i), endDates.get(i)));
        }
        
        Transaction transaction = new Transaction(blocksToAdd) ;
        
        StringBuilder sb = new StringBuilder() ;
        
        while (transaction.hasNext()) {
            try {
                Block addedTask = transaction.addNext(model) ;
                
                sb.append(DateUtil.parseLocalDateTimeIntoString(addedTask.getStartDate()) 
                        + " to " 
                        + DateUtil.parseLocalDateTimeIntoString(addedTask.getEndDate())) ;
                
                sb.append(" and ") ;
            
            } catch (DuplicateTaskException e) {
               
               transaction.rollback(model);
               return new CommandResult(MESSAGE_DUPLICATE_TASK) ;
            }
        }
        
        
        // Remove the last " and " 
        sb.delete(sb.length() - 5, sb.length()) ;
        
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, name, sb.toString()), true ) ;
    }
    
    
    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>>(ImmutableList.copyOf(blocksToAdd), Collections.emptyList()) ; 
    }
    
    private static class Transaction {
        
        private List<Block> taskToAdd ;
        private int index ;
        
        public Transaction(List<Block> tasks) {
            this.taskToAdd = tasks ;
            this.index = 0 ;
        }
        
        public Block addNext (Model model) throws DuplicateTaskException {
            
            Block task = taskToAdd.get(index) ;
            
            model.addTask(task);
            index ++ ;
            
            return task ;
        }
        
        public boolean hasNext () {
            return index < taskToAdd.size() ;
        }
        
        public void rollback(Model model) {
            
            if (index == 0) {
                return ;
            }
            
            for (int i = index - 1; i >= 0; i --) {
                try {
                    model.deleteTask(taskToAdd.get(i));
                } catch (TaskNotFoundException e) {
                    continue ;
                }
            }
        }
    }
}
```
###### \java\seedu\address\logic\commands\ConfigCommand.java
``` java
public class ConfigCommand extends Command {
    
    public static final String COMMAND_WORD = "config";
    
    public static final String INVALID_CONFIG = "The given config option is not valid!" ;
    public static final String INVALID_CONFIG_VALUE = "The given config option and or value is not valid!" ;
    
    public static final String MESSAGE_IOEXCEPTION = "Something went wrong when saving the config file! Your file might be corrupted."
            + "Please try to delete it and load the app up again for the default config file!" ;
    public static final String MESSAGE_SUCCESS = "The following configuration option: %1$s is successfully set to %2$s" ;
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the given config option to the given value \n"
            + "Format: config CONFIG_OPTION v/NEW VALUE \n"
            + "Example: config activeHoursFrom v/1000" ;
    
    private static final String RESET_TO_DEFAULT = "default" ;
    
    private final String configOption ;
    private final String value ;
    private final Class<?> configValueType ;
    
    
    public ConfigCommand(String configOption, String value) throws IllegalValueException {
        this.configOption = configOption ;
        this.value = value ;
        this.configValueType = Config.getConfigValueType(configOption) ;
        
        if (configValueType == null) {
            throw new IllegalValueException(INVALID_CONFIG) ;
        }
    }
    
    @Override
    public CommandResult execute() {
        
        Config config = model.getConfigs() ;
        Object newConfigValue = value ;
        
        if (RESET_TO_DEFAULT.equalsIgnoreCase(value)) {
            final Object defaultValue = (config.getDefaultConfigs().get(configOption) != null) ? 
                    config.getDefaultConfigs().get(configOption).getValue() : null ;
             
            if (defaultValue == null) {
                return new CommandResult(INVALID_CONFIG) ;
            }
            
            newConfigValue = defaultValue.toString() ;
        }
        
        try {
            newConfigValue = castStringIntoValue(configValueType, newConfigValue) ;
            
            config.setConfigurationOption(configOption, newConfigValue );
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
        
        } catch (ClassCastException e) {
            return new CommandResult(INVALID_CONFIG_VALUE) ;
        
        } catch (IOException e) {
            return new CommandResult(MESSAGE_IOEXCEPTION) ;
        }
        
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, configOption, newConfigValue), true) ;
    }
    
    private Object castStringIntoValue (Class<?> clazz, Object value) {
        
        if (String.class.getName().equals(clazz.getName())) {
            return value.toString() ;
        }
        
        if (Boolean.class.getName().equals(clazz.getName())) {
            return ("true".equalsIgnoreCase(value.toString()) || "1".equals(value.toString())) ?
                    Boolean.TRUE : Boolean.FALSE ;
        }
        
        if (Integer.class.getName().equals(clazz.getName())) {
            return Integer.parseInt(value.toString()) ;
        }
        
        return null ;
    }

}
```
###### \java\seedu\address\logic\commands\ConfirmCommand.java
``` java
 *
 * A command to confirm a previously blocked out timeslot(s)
 *
 */
public class ConfirmCommand extends Command {

    public static final String COMMAND_WORD = "confirm" ;

    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the ToDo list!";
    public static final String MESSAGE_CONFIRM_SUCCESS = "The following event is successfully confirmed: %1$s" ;
    public static final String MESSAGE_DATES_NOT_NULL = "Please enter in a pair of valid start and end dates/times!" ;
    public static final String MESSAGE_ONLY_BLOCKS = "You can only confirm an unconfirmed event!" ;
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Confirms a previously blocked timeslot into an event. \n"
            + "The start and end date provided is the confirmed dates. \n"
            + "Format: confirm INDEX st/START TIME et/END TIME [d/DESCRIPTION] [t/tag...] \n"
            + "Example: confirm meeting with boss st/today 2pm et/today 4pm" ;

    private final int targetIndex ;
    private final String startDate ;
    private final String endDate ;
    private final String description ;
    private final Set<String> taglist ;
    private final List<ReadOnlyTask> deletedTask, addedTask ;

    public ConfirmCommand (int targetIndex, String description, String startDate, String endDate, Set<String> tags) throws IllegalValueException {

        if (startDate == null || endDate == null) {
            throw new IllegalValueException(MESSAGE_DATES_NOT_NULL) ;
        }

        this.targetIndex = targetIndex ;
        this.startDate = startDate ;
        this.endDate = endDate ;
        this.description = description ;
        this.taglist = tags ;
        
        this.deletedTask = new ArrayList<>() ;
        this.addedTask = new ArrayList<>() ;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTask();

        if (lastShownList.size() < targetIndex || targetIndex < 1) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask blockToConfirm = lastShownList.get(targetIndex - 1);
        int id = model.getNextTaskId() ;

        if (!(blockToConfirm instanceof Block) ) {

            return new CommandResult(MESSAGE_ONLY_BLOCKS) ;
        }
        
        Optional<Pair<LocalDateTime, LocalDateTime>> datePair = DateUtil.determineStartAndEndDateTime(startDate, endDate) ;
        
        if (!datePair.isPresent()) {
            return new CommandResult(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE)) ;
        }

        findAndDeleteOtherBlocks( (Block) blockToConfirm) ;

        String name = blockToConfirm.getName() ;
        
        final Set<Tag> newTags = Sets.newHashSet() ;
        
        try {
            for (String tagName : taglist) {
                newTags.add(model.getTagRegistry().getTagFromString(tagName, true)) ;
            }
            
        }catch (IllegalValueException e) {
            return new CommandResult(e.getMessage()) ;
        }
        
        Task newEvent = new Event(id, name, description, datePair.get().getKey(), datePair.get().getValue(), new UniqueTagList(newTags)) ;
        Optional<Event> conflict = DateUtil.checkForConflictingEvents(model, (Event) newEvent) ;

        try {
            model.addTask(newEvent) ;
            addedTask.add(newEvent) ;

        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK) ;
        }
        
        String successMessage = String.format(MESSAGE_CONFIRM_SUCCESS, newEvent) ;
        
        if ( conflict.isPresent() ) {
            successMessage = successMessage.concat("\n" + Messages.CONFLICTING_EVENTS_DETECTED + "The event is: " + conflict.get().getName()) ;
        }
        return new CommandResult(successMessage, true) ;
    }

    private void findAndDeleteOtherBlocks (Block task) {
        List<ReadOnlyTask> list = findAllOtherBlocks (task) ;

        for (ReadOnlyTask taskToDelete : list) {
            try {
                model.deleteTask(taskToDelete) ;
                deletedTask.add(taskToDelete) ;
                
            } catch (TaskNotFoundException e) {

                continue ;
            }
        }
    }

    private List<ReadOnlyTask> findAllOtherBlocks (Block task) {

        assert model != null ;

        int taskId = task.getTaskId() ;

        Expression filterByID = new PredicateExpression(new TaskIdentifierNumberQualifier(taskId)) ;
        model.searchTaskList(filterByID);

        return new ArrayList<>(model.getSearchedTaskList()) ;
    }
    
    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>>(ImmutableList.copyOf(addedTask), ImmutableList.copyOf(deletedTask)) ; 
    }
}
```
###### \java\seedu\address\logic\commands\DeleteCommand.java
``` java
 * 
 * Deletes a task identified using it's last displayed index from the taskForce list.
 */
public class DeleteCommand extends Command {

    public static final String[] COMMAND_WORD = {
            "delete",
            "remove",
    };

    public static final String DEFAULT_COMMAND_WORD = COMMAND_WORD[0] ;


    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task(s): %1$s ";
    public static final String MESSAGE_DELETE_TASK_NOT_FOUND = "Task(s) not found: %1$s ";
    public static final String MESSAGE_DELETE_TASK_IGNORED = "The following indexes are invalid and ignored: %1$s ";

    public final List<Integer> targetIndexes;
    
    private final List<ReadOnlyTask> deletedTasks ;

    public DeleteCommand(Integer... targetIndex) {
        this.targetIndexes = Lists.newLinkedList() ;
        this.deletedTasks = Lists.newLinkedList() ;
        
        for (int index : targetIndex) {
            this.targetIndexes.add(index) ;
        }
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTask();
        
        List<ReadOnlyTask> tasksToDelete = Lists.newLinkedList() ;
        
        DeleteMessageBuilder messageBuilder = new DeleteMessageBuilder() ;
        
        for (int targetIndex : targetIndexes) {
            if (lastShownList.size() < targetIndex) {
                messageBuilder.addIgnoredIndex(targetIndex) ;
            } else {
                tasksToDelete.add(lastShownList.get(targetIndex - 1)) ;
            }
        }
        
        if (tasksToDelete.isEmpty()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        
        for (ReadOnlyTask task : tasksToDelete) {
    
            try {
                model.deleteTask(task);
                deletedTasks.add(task) ;
                
                messageBuilder.addDeletedTaskDetails(task.getName()) ;
            } catch (TaskNotFoundException pnfe) {
                messageBuilder.addTaskNotFound(task.getName());
            }
        }
        
     
        return new CommandResult(messageBuilder.getDeleteCommandResultString(), true);
    }
    
    /**
     * 
     * A specialized class to build the success/failure message for the delete command
     *
     */
    public static class DeleteMessageBuilder {
        
        private StringBuilder deletedTask ;
        private StringBuilder ignoredIndexes ;
        private StringBuilder tasksNotFound ;
        
        public DeleteMessageBuilder () {
            this.deletedTask = new StringBuilder () ;
            this.ignoredIndexes = new StringBuilder () ;
            this.tasksNotFound = new StringBuilder () ;
        }
        
        public void addDeletedTaskDetails (String taskName) {
            deletedTask.append(taskName + " and ") ;
        }
        
        public void addIgnoredIndex (int index) {
            ignoredIndexes.append(index) ;
        }
        
        public void addTaskNotFound (String taskName) {
            tasksNotFound.append(taskName + " and ") ;
        }
        
        public String getDeletedTasks () {
            String result = deletedTask.toString() ;
            
            if (result.length() > 0) {
                return result.substring(0, result.length() - 5) ;
            }
            
            return "" ;
        }
        
        public String getIgnoredIndexes () {
            return ignoredIndexes.toString() ;
        }
        
        public String getTasksNotFound () {
            String result = tasksNotFound.toString() ;
            
            if (result.length() > 0) {
                return result.substring(0, result.length() - 5) ; 
            }
            
            return "" ;
        }
        
        public String getDeleteCommandResultString () {
            StringBuilder sb = new StringBuilder() ;
            
            String taskNotFound = getTasksNotFound() ;
            String indexesIgnored = getIgnoredIndexes() ;
            String deletedTasks = getDeletedTasks() ;
            
            if (deletedTasks.length() > 0) {
                sb.append(String.format(MESSAGE_DELETE_TASK_SUCCESS, deletedTasks)) ;
            }

            if (taskNotFound.length() > 0) {
                sb.append("\n") ;
                sb.append(String.format(MESSAGE_DELETE_TASK_NOT_FOUND, taskNotFound)) ;
            }
            
            if (indexesIgnored.length() > 0) {
                sb.append("\n") ;
                sb.append(String.format(MESSAGE_DELETE_TASK_IGNORED, indexesIgnored)) ;
            }
            
            return sb.toString() ;
        }
    }

    @Override
    public Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> getCommandChanges() {
        return new Pair<List<ReadOnlyTask>, List<ReadOnlyTask>> (Collections.emptyList(), ImmutableList.copyOf(deletedTasks)) ;
    }
    

}
```
###### \java\seedu\address\logic\filters\TaskIdentifierNumberQualifier.java
``` java
 * 
 * A simple qualifier to filter tasks via their task ID.
 *
 */
public class TaskIdentifierNumberQualifier implements Qualifier {
    
    private final int filterId ;
    
    public TaskIdentifierNumberQualifier (int idToFilter) {
        this.filterId = idToFilter ;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        
        return task != null && task.getTaskId() == filterId ;
    }

}
```
###### \java\seedu\address\logic\parser\AddCommandParser.java
``` java
	private static <T> T getArgValueFromOptional (Optional<T> argValue, T defaultValue) {
	    
	    if (argValue.isPresent()) {
	        return argValue.get() ;
	    }
	    
	    return defaultValue ;
	}

}
```
###### \java\seedu\address\logic\parser\ArgumentsParser.java
``` java
 *  
 * Given a command string with arguments, this class will extract the values from the string
 * for easy retrieval
 * 
 *
 */
public class ArgumentsParser {

    public static final int INVALID_VALUE_LENGTH = 0;

    private CommandArgs noFlagArgument ;
    private Set<CommandArgs> requiredArguments ;
    private Set<CommandArgs> optionalArguments ;
    private Multimap<CommandArgs, String> argumentValuesMap ;
    private Map<String, CommandArgs> flags ;

    public ArgumentsParser() {
        this (false) ;

    }

    public ArgumentsParser (boolean maintainOrdering) {
        requiredArguments = Sets.newHashSet() ;
        optionalArguments = Sets.newHashSet() ;

        if (!maintainOrdering) {
            argumentValuesMap = ArrayListMultimap.create();

        } else {
            argumentValuesMap = LinkedListMultimap.create() ;

        }

        flags = Maps.newHashMap() ;

        this.addNoFlagArg(CommandArgs.NULL_ARG) ;
    }

    private void addFlag (CommandArgs arg) {
        for (String s : arg.getAliases()) {
            flags.put(s, arg) ;
        }
    }

    /**
     * Adds a no flag argument to this parser. A no flag argument is defined to be an argument that appears at the very
     * start of the command string. No flag arguments are required and there can only be one no flag argument in any
     * command string
     * 
     * @param arg
     * @return
     */
    public ArgumentsParser addNoFlagArg (CommandArgs arg) {
        noFlagArgument = arg ;
        addFlag(arg) ;

        return this ;
    }

    /** 
     * Adds a required argument. <p>
     * 
     * A required argument is defined to be an argument that if not present in the given command string,
     * the command string will be deemed improper.
     * 
     * @param arg
     * @return this object for daisy chaining.
     */
    public ArgumentsParser addRequiredArg (CommandArgs arg) {
        requiredArguments.add(arg) ;
        addFlag(arg) ;

        return this ;
    }

    /** 
     * Adds a optional argument. <p>
     * 
     * A optional argument is defined to be an argument that may or may not be present in the given command string.
     * The command string will be deemed valid in both cases
     * 
     * @param arg
     * @return this object for daisy chaining.
     */
    public ArgumentsParser addOptionalArg (CommandArgs arg) {
        optionalArguments.add(arg) ;
        addFlag(arg) ;

        return this ;
    }

    /**
     * Retrieves the associated values as a List of strings. <p>
     * For example e/tag1 e/tag2 would return {tag1, tag2}. If there is only one value, this will return a singleton list.
     * <p>
     * If there is no such flag present, return an {@code Optional.empty()}.
     * 
     * @param arg
     * @return
     */
    public Optional<List<String>> getArgValues(CommandArgs arg) {
        List<String> result = Lists.newLinkedList() ;

        if (!argumentValuesMap.containsKey(arg)) {
            return Optional.empty() ;
        }

        result.addAll(argumentValuesMap.get(arg)) ;

        return Optional.of(result) ;
    }

    /**
     * Retrieves the associated values as a string. <p>
     * Note if there is more than one value associated to this flag, only the first arbitrary one will be returned.
     * <p>
     * If there is no such flag present, return an {@code Optional.empty()}.
     * 
     * @param arg
     * @return
     */
    public Optional<String> getArgValue(CommandArgs arg) {
        return getArgValues(arg).isPresent() ? Optional.of(getArgValues(arg).get().get(0)) : Optional.empty() ;
    }

    /**
     * Returns true if and only if the parsed command string contains a flag-value pair
     * containing at least one value
     *  
     * @param flag
     * @return
     */
    public boolean containsFlag(CommandArgs flag) {
        return argumentValuesMap.containsKey(flag) ;
    }

    /**
     * Parses the given commandString into their individual flag-value pairs.
     * 
     * @param commandString
     * @throws IncorrectCommandException if given command string does not match the required format
     */
    public void parse(String commandString) throws IncorrectCommandException {

        Deque<Character> charStack = Lists.newLinkedList();
        CommandArgs thisArg = noFlagArgument ;

        String commandStringTrimmed = commandString.trim().concat(" $/") ; // Append a unique "end of string" character

        for (int i = 0; i < commandStringTrimmed.length(); i ++) {

            if (commandStringTrimmed.charAt(i) != '/') {
                charStack.push(commandStringTrimmed.charAt(i));
                continue;
            }

            if(thisArg == null) {
                throw new IncorrectCommandException();
            }

            CommandArgs nextArg = flags.get(extractFlagFromString(charStack)) ;
            String value = extractArgValueFromString(charStack) ;

            if(thisArg != CommandArgs.NULL_ARG && value.length() == INVALID_VALUE_LENGTH) {
                throw new IncorrectCommandException() ;
            }

            argumentValuesMap.put(thisArg, value) ;
            thisArg = nextArg ;


        }

        if (!isCommandStringValid()) {
            throw new IncorrectCommandException() ; 
        }

    }

    private String extractFlagFromString(Deque<Character> stack) {

        StringBuilder sb = new StringBuilder() ;
        sb.append('/') ;

        while (stack.peekFirst() != null && stack.peekFirst() != ' ') {
            sb.append(stack.pop()) ;
        }

        if (!stack.isEmpty()) {
            stack.pop() ;
        }

        return sb.reverse().toString() ;
    }

    private String extractArgValueFromString(Deque<Character> stack) {
        StringBuilder sb = new StringBuilder() ;

        while (stack.peekFirst() != null) {
            sb.append(stack.pop()) ;
        }

        return sb.reverse().toString() ;
    }

    /**
     * A command string provided by the user is valid if and only if all required arguments are present.
     * Requires the command string to be properly parsed first
     * 
     * @return true if command string provided by user is valid; false otherwise
     */
    private boolean isCommandStringValid() {

        Set<CommandArgs> argsPresent = argumentValuesMap.keySet() ;

        return argsPresent.containsAll(requiredArguments) ;
    }

}
```
###### \java\seedu\address\logic\parser\BlockCommandParser.java
``` java
public class BlockCommandParser extends CommandParser{

    @Override
    public Command prepareCommand(String args) {

        ArgumentsParser parser = new ArgumentsParser(true) ;
        
        parser
        .addNoFlagArg(CommandArgs.NAME)
        .addRequiredArg(CommandArgs.END_DATETIME)
        .addRequiredArg(CommandArgs.START_DATETIME) ;
        
        try {
            parser.parse(args) ;
        } catch (IncorrectCommandException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE));
        }
        
        List<LocalDateTime> startDateTimes = Lists.newLinkedList() ;
        List<LocalDateTime> endDateTimes = Lists.newLinkedList() ;
        
        try {
            convertArgsToDateTime(parser, startDateTimes, endDateTimes) ;
        
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        }
        
        try {
            return new BlockCommand(parser.getArgValue(CommandArgs.NAME).get(), startDateTimes, endDateTimes) ;
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }
    
    private void convertArgsToDateTime (ArgumentsParser parser, List<LocalDateTime> startTimes, List<LocalDateTime> endTimes)
    throws IllegalValueException {
        
        assert parser != null ;
        
        List<String> startStrings = parser.getArgValues(CommandArgs.START_DATETIME).orElse(Collections.emptyList()) ;
        List<String> endStrings = parser.getArgValues(CommandArgs.END_DATETIME).orElse(Collections.emptyList()) ;
        
        if (!startStrings.isEmpty() && !endStrings.isEmpty() && startStrings.size() == endStrings.size()) {
            
            for (int i = 0; i < startStrings.size(); i ++) {
                Pair<LocalDateTime, LocalDateTime> startEndDates =  
                        DateUtil.determineStartAndEndDateTime(startStrings.get(i), endStrings.get(i), false)
                        .orElseThrow(() -> new IllegalValueException(AddCommand.INVALID_END_DATE_MESSAGE)) ;
                
                startTimes.add(startEndDates.getKey()) ;
                endTimes.add(startEndDates.getValue()) ;
            }
            
        } else {
            throw new IllegalValueException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE)) ;
        }
        
    }
}
```
###### \java\seedu\address\logic\parser\ConfigCommandParser.java
``` java
public class ConfigCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        ArgumentsParser parser = new ArgumentsParser() ;
        
        parser
        .addNoFlagArg(CommandArgs.NAME)
        .addRequiredArg(CommandArgs.VALUES) ;
        
        try {
            parser.parse(args) ;
        } catch (IncorrectCommandException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, ConfigCommand.MESSAGE_USAGE));
        }
        
        try {
            return new ConfigCommand(parser.getArgValue(CommandArgs.NAME).get(), parser.getArgValue(CommandArgs.VALUES).get()) ;
        
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage()) ;
        }
        
    }

}
```
###### \java\seedu\address\logic\parser\DeleteCommandParser.java
``` java
 * 
 * parsing arguments to and preparing them for delete command
 */
public class DeleteCommandParser extends CommandParser {
    
    @Override
    public Command prepareCommand(String args) {
        
        String[] indexes = args.split(",") ;
        List<Integer> indexList = Lists.newLinkedList() ;
        
        for (String i : indexes) {
            Optional<Integer> index = parseIndex(i);
            
            if(!index.isPresent()){
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            
            indexList.add(index.get()) ;
        }
        
        Integer[] indexArray = new Integer[indexList.size()] ;
        
        return new DeleteCommand(indexList.toArray(indexArray));
    }
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
     * 
     * Registers all associated command word strings with the provided command parser class.
     * One command parser can be associated with multiple command words such as ("add", "schedule", etc)
     * 
     */
    public static void registerCommand(Class<? extends CommandParser> parser, String... command) {
    	
    	for (String word : command) {
    		commandRegistry.put(word, parser);
    	}	
    }
    
    public static CommandParser getParserFromCommandWord (String commandWord) {
    	
    	if (!commandRegistry.containsKey(commandWord)) {
    		return new IncorrectCommandParser();
    	}
    	
    	Class<? extends CommandParser> parser = commandRegistry.get(commandWord) ;
    	
    	try {
    		CommandParser commandParser = parser.newInstance() ;
    		
    		return commandParser ;
    	} catch (Exception e) {
    		return new IncorrectCommandParser() ;
    	}
    }


    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        return getParserFromCommandWord(commandWord).prepareCommand(arguments);
        
    }        

}
```
###### \java\seedu\address\model\tag\ReadOnlyTagRegistrar.java
``` java
 * 
 * A tag registry that disallows classes to reset the whole registry.
 */
public interface ReadOnlyTagRegistrar {
    
    public static final String MESSAGE_DUPLICATE_NAME = "The given tag name already exists!" ;
    
    /**
     * Given a tag string to the registry, the registry will return the Tag object with tag name
     * matching the given string.
     * <p>
     * Additionally if register is set to true,
     * if the tag is not currently in the registry, this create a new Tag object with the given
     * string and returns it. <br>
     * 
     * If not, this function returns null ;
     * 
     * @param tagString     The tag name to be queried
     * @param register      If true, this will register a new tag with the given name if not found; otherwise this will return null;
     * @return      A tag object with the given tag name 
     * @throws IllegalValueException if the given tag string is illegal and/or invalid
     */
    public Tag getTagFromString (String tagString, boolean register) throws IllegalValueException ;
    
    /**
     * Given an existing tag, change its name to the given string
     * 
     * @param tag   The tag object whose name is to be modified
     * @param newName   the name to change into
     * 
     * @throws IllegalValueException if the given name is invalid and/or already exists.
     */
    public void changeTagName(Tag tag, String newName) throws IllegalValueException ;

}
```
###### \java\seedu\address\model\tag\TagRegistrar.java
``` java
 * 
 * <p>
 * 
 * Provides a central class to handle tag creation to prevent duplicate tags with similar names
 *
 */
public class TagRegistrar implements ReadOnlyTagRegistrar {
    
    private final Map<String, Tag> tagRegistry = Maps.newHashMap() ;
    
    @Override
    public Tag getTagFromString (String tagString, boolean register) throws IllegalValueException {
        
        String key = parseInput(tagString) ;
        
        if (tagRegistry.containsKey(key)) {
            return tagRegistry.get(key) ;
        }
        
        return (register) ? registerNewTag(key) : null ;
    }
    
    private Tag registerNewTag (String tagString) throws IllegalValueException {
        String newTagString = parseInput(tagString) ;
        Tag newTag = new Tag(newTagString) ;
        
        tagRegistry.put(newTagString, newTag) ;
        
        return newTag ;
    }
    
    private String parseInput (String input) {
        return (input != null) ? input.trim().toLowerCase() : null ;
    }
    
    /**
     * Resets the registry and re-populate it with the given tags
     * @param tagIterable
     */
    public void setAllTags (Iterable<Tag> tagIterable) {
        tagRegistry.clear() ;
        
        for (Tag tag : tagIterable) {
            tagRegistry.put(parseInput(tag.tagName), tag) ;
        }
    }
    
    public void changeTagName(Tag tag, String newName) throws IllegalValueException {
        String name = parseInput(newName) ;
        String curName = tag.tagName ;
        
        if (tagRegistry.containsKey(name)) {
            throw new IllegalValueException(MESSAGE_DUPLICATE_NAME) ;
        }
        
        tag.setTagName(name) ;
        
        tagRegistry.remove(curName) ;
        tagRegistry.put(name, tag) ;
    }
}
```
###### \java\seedu\address\model\task\Block.java
``` java
 * 
 * A block is a special event that is unconfirmed.
 *
 */
public class Block extends Event {

    public Block(int taskId, String name, LocalDateTime startDate, LocalDateTime endDate) {
        super(taskId, name, "" , startDate, endDate, new UniqueTagList());
    }

}
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
     * 
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        
        Task task ;
        LocalDateTime start = null ;
        LocalDateTime end = null ;
        
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final String name = this.name ;
        final String description = this.description ;
        final boolean doneStatus = this.doneStatus;
        final boolean isBlock = this.isBlock ;
        final UniqueTagList tags = new UniqueTagList(taskTags);
        final int id = this.taskId ;
        
        if (this.startDateTime != null) {
            start = LocalDateTime.parse(this.startDateTime) ;
        }
        
        if (this.endDateTime != null) {
            end = LocalDateTime.parse(this.endDateTime) ;
        }
        
        if (isBlock) {
            task = new Block(id, name, start, end) ;
        
        } else if (start != null && end != null) {
            task = new Event (id, name, description, start, end, tags, doneStatus) ; 
        
        } else if (start == null && end != null) {
            task = new Deadline (id, name, description, end, tags, doneStatus) ;
        
        } else {
            task = new Task(id, name, description, tags, doneStatus);
        }
        
        return task ;
    }
}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    private void loadCustomTrueTypeFonts() {
        // Loads the Open sans custom truetype font
        Font.loadFont(this.getClass().getResourceAsStream("/images/OpenSans-Light.ttf"), 12) ;
        Font.loadFont(this.getClass().getResourceAsStream("/images/OpenSans-Semibold.ttf"), 12) ;
    }
    
```
###### \java\seedu\address\ui\NodeStyle.java
``` java
public enum NodeStyle {
    
    CIRCLE_HIGH ("CIRCLE", "circle_high", 0) ,
    CIRCLE_MED ("CIRCLE", "circle_med", Integer.MAX_VALUE) ,
    CIRCLE_LOW ("CIRCLE", "circle_low", 0) ,
    CIRCLE_DONE ("CIRCLE", "circle_done", -1) ,
    CIRCLE_BLOCK ("CIRCLE", "circle_block", -1) ,
    
    TITLE_NORMAL ("TITLE", "cell_big_label", Integer.MAX_VALUE) ,
    TITLE_OVERDUE ("TITLE", "cell_big_label_overdue", -2) ,
    TITLE_BLOCK ("TITLE", "cell_big_label_block", -1) ,
    TITLE_DONE ("TITLE", "cell_big_label_done", Integer.MIN_VALUE),
    
    TIME_NORMAL ("TIME", "cell_small_label", Integer.MAX_VALUE) ,
    TIME_BLOCK ("TIME", "time_block", -1) ,
    TIME_UPCOMING ("TIME", "time_upcoming", -1),
    TIME_OVERDUE ("TIME", "time_overdue", -2),
    TIME_DONE ("TIME", "time_done", Integer.MIN_VALUE)
    
    ;
    
    
    public final String family ;
    public final String className ;
    /** lower priority number = more important */
    public final int priority ; 
    
    private NodeStyle (String family, String className, int priority) {
        this.family = family ;
        this.className = className ;
        this.priority = priority ;
    }

}
```
###### \java\seedu\address\ui\ResultDisplay.java
``` java
    public void commandExecuted (boolean success) {
        String addedClass ;
        
        if (!success) {
            addedClass = "badCommand" ;
        } else {
            addedClass = "validCommand" ; 
        }
        
        resultDisplayArea.getStyleClass().add(addedClass) ; 
        
        Timeline reduceBorder = new Timeline(new KeyFrame(
                Duration.millis(2500),
                runnable -> reduceBorderWidth() ));
        
        Timeline backToNormal = new Timeline(new KeyFrame(
                Duration.millis(5000),
                runnable -> changeBorderBack (addedClass)));
        
        reduceBorder.play();
        backToNormal.play();
    }
    
    private void changeBorderBack(String classToRemove) {
        resultDisplayArea.getStyleClass().remove(classToRemove) ;
    }
    
    private void reduceBorderWidth () {
        resultDisplayArea.setStyle ("-fx-border-width: 2px ;") ;
    }

}
```
###### \resources\view\Extensions.css
``` css

.command-box {
	-fx-background-insets: 0;
	-fx-border-insets: 0;
    -fx-background-color: transparent, #f46060, transparent, #f46060;
    -fx-border-width: 1px ;
    -fx-border-color: #f46060 #f46060 #ffffff #f46060;
}

.result-display {
	-fx-font-family: "Open Sans Light" ;
	-fx-font-size: 14pt;
	-fx-text-fill: #7f7f7f ;
	-fx-background-insets: 0;
    -fx-background-color: transparent, #ececec, transparent, #ececec;
}

.badCommand {
	-fx-border-width: 3px ;
    -fx-border-color: #de5347 ;
    -fx-text-fill: #de5347 ;
}

.validCommand {
	-fx-border-width: 3px ;
    -fx-border-color: #1aa260 ;
    -fx-text-fill: #1aa260 ;
}

.error {
    -fx-background-color: #b50000;
}


.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}

.tooltip-text {
    -fx-text-fill: white;
}

/*
 * ====================================================================
 * ======================STYLES FOR CIRCLES============================
 * ====================================================================
 */

.circle_low {
	-fx-fill: derive(#4b8bf5, 0%);
}

.circle_med {
	-fx-fill: derive(#ffce43, 0%);
}
.circle_high {
	-fx-fill: derive(#de5347, 0%);
}

.circle_done {
	-fx-fill: derive(#1aa260, 0%);
}

.circle_block {
	-fx-fill: none ;
}

/*
 * ====================================================================
 * ======================STYLES FOR TITLEs=============================
 * ====================================================================
 */
 
.cell_big_label_done .text {
	-fx-font-family: "Open Sans Light";
	-fx-strikethrough: true ;
	-fx-font-size: 16px;
    -fx-text-fill: #010504 ;
}

.cell_big_label_overdue {
	-fx-font-family: "Open Sans Semibold";
    -fx-font-size: 16px;
    -fx-font-weight: bold ;
    -fx-text-fill: #f46060 !important ;
}

.cell_big_label_block {
	-fx-font-family: "Open Sans Light";
    -fx-font-size: 16px;
    -fx-text-fill: #4f4f4e !important ;
}

.time_block {
	-fx-text-fill: #4f4f4e !important ;
	-fx-font-size: 10pt;
}

.time_upcoming {
	-fx-text-fill: #4b8bf5 !important ;
	-fx-font-family: "Open Sans Semibold";
	-fx-font-size: 10pt;
}

.time_overdue {
	-fx-text-fill: #f46060 !important ;
	-fx-font-size: 10pt;
}

.time_done {
	-fx-text-fill: #010504 !important ;
	-fx-font-size: 10pt;
}

```
